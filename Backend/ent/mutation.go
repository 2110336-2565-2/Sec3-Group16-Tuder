// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/class"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/course"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/issuereport"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/match"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/payment"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/paymenthistory"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/predicate"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/reviewcourse"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/reviewtutor"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/schedule"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/student"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/tutor"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/user"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClass          = "Class"
	TypeCourse         = "Course"
	TypeIssueReport    = "IssueReport"
	TypeMatch          = "Match"
	TypePayment        = "Payment"
	TypePaymentHistory = "PaymentHistory"
	TypeReviewCourse   = "ReviewCourse"
	TypeReviewTutor    = "ReviewTutor"
	TypeSchedule       = "Schedule"
	TypeStudent        = "Student"
	TypeTutor          = "Tutor"
	TypeUser           = "User"
)

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	review_avaliable       *bool
	total_hour             *int
	addtotal_hour          *int
	success_hour           *int
	addsuccess_hour        *int
	status                 *class.Status
	clearedFields          map[string]struct{}
	match                  map[uuid.UUID]struct{}
	removedmatch           map[uuid.UUID]struct{}
	clearedmatch           bool
	schedule               *uuid.UUID
	clearedschedule        bool
	payment_history        *uuid.UUID
	clearedpayment_history bool
	done                   bool
	oldValue               func(context.Context) (*Class, error)
	predicates             []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id uuid.UUID) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Class entities.
func (m *ClassMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReviewAvaliable sets the "review_avaliable" field.
func (m *ClassMutation) SetReviewAvaliable(b bool) {
	m.review_avaliable = &b
}

// ReviewAvaliable returns the value of the "review_avaliable" field in the mutation.
func (m *ClassMutation) ReviewAvaliable() (r bool, exists bool) {
	v := m.review_avaliable
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewAvaliable returns the old "review_avaliable" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldReviewAvaliable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewAvaliable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewAvaliable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewAvaliable: %w", err)
	}
	return oldValue.ReviewAvaliable, nil
}

// ResetReviewAvaliable resets all changes to the "review_avaliable" field.
func (m *ClassMutation) ResetReviewAvaliable() {
	m.review_avaliable = nil
}

// SetTotalHour sets the "total_hour" field.
func (m *ClassMutation) SetTotalHour(i int) {
	m.total_hour = &i
	m.addtotal_hour = nil
}

// TotalHour returns the value of the "total_hour" field in the mutation.
func (m *ClassMutation) TotalHour() (r int, exists bool) {
	v := m.total_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalHour returns the old "total_hour" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldTotalHour(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalHour: %w", err)
	}
	return oldValue.TotalHour, nil
}

// AddTotalHour adds i to the "total_hour" field.
func (m *ClassMutation) AddTotalHour(i int) {
	if m.addtotal_hour != nil {
		*m.addtotal_hour += i
	} else {
		m.addtotal_hour = &i
	}
}

// AddedTotalHour returns the value that was added to the "total_hour" field in this mutation.
func (m *ClassMutation) AddedTotalHour() (r int, exists bool) {
	v := m.addtotal_hour
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalHour resets all changes to the "total_hour" field.
func (m *ClassMutation) ResetTotalHour() {
	m.total_hour = nil
	m.addtotal_hour = nil
}

// SetSuccessHour sets the "success_hour" field.
func (m *ClassMutation) SetSuccessHour(i int) {
	m.success_hour = &i
	m.addsuccess_hour = nil
}

// SuccessHour returns the value of the "success_hour" field in the mutation.
func (m *ClassMutation) SuccessHour() (r int, exists bool) {
	v := m.success_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessHour returns the old "success_hour" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldSuccessHour(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessHour: %w", err)
	}
	return oldValue.SuccessHour, nil
}

// AddSuccessHour adds i to the "success_hour" field.
func (m *ClassMutation) AddSuccessHour(i int) {
	if m.addsuccess_hour != nil {
		*m.addsuccess_hour += i
	} else {
		m.addsuccess_hour = &i
	}
}

// AddedSuccessHour returns the value that was added to the "success_hour" field in this mutation.
func (m *ClassMutation) AddedSuccessHour() (r int, exists bool) {
	v := m.addsuccess_hour
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessHour resets all changes to the "success_hour" field.
func (m *ClassMutation) ResetSuccessHour() {
	m.success_hour = nil
	m.addsuccess_hour = nil
}

// SetStatus sets the "status" field.
func (m *ClassMutation) SetStatus(c class.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ClassMutation) Status() (r class.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldStatus(ctx context.Context) (v class.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ClassMutation) ResetStatus() {
	m.status = nil
}

// AddMatchIDs adds the "match" edge to the Match entity by ids.
func (m *ClassMutation) AddMatchIDs(ids ...uuid.UUID) {
	if m.match == nil {
		m.match = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.match[ids[i]] = struct{}{}
	}
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *ClassMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *ClassMutation) MatchCleared() bool {
	return m.clearedmatch
}

// RemoveMatchIDs removes the "match" edge to the Match entity by IDs.
func (m *ClassMutation) RemoveMatchIDs(ids ...uuid.UUID) {
	if m.removedmatch == nil {
		m.removedmatch = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.match, ids[i])
		m.removedmatch[ids[i]] = struct{}{}
	}
}

// RemovedMatch returns the removed IDs of the "match" edge to the Match entity.
func (m *ClassMutation) RemovedMatchIDs() (ids []uuid.UUID) {
	for id := range m.removedmatch {
		ids = append(ids, id)
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
func (m *ClassMutation) MatchIDs() (ids []uuid.UUID) {
	for id := range m.match {
		ids = append(ids, id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *ClassMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
	m.removedmatch = nil
}

// SetScheduleID sets the "schedule" edge to the Schedule entity by id.
func (m *ClassMutation) SetScheduleID(id uuid.UUID) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *ClassMutation) ClearSchedule() {
	m.clearedschedule = true
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *ClassMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *ClassMutation) ScheduleID() (id uuid.UUID, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *ClassMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// SetPaymentHistoryID sets the "payment_history" edge to the PaymentHistory entity by id.
func (m *ClassMutation) SetPaymentHistoryID(id uuid.UUID) {
	m.payment_history = &id
}

// ClearPaymentHistory clears the "payment_history" edge to the PaymentHistory entity.
func (m *ClassMutation) ClearPaymentHistory() {
	m.clearedpayment_history = true
}

// PaymentHistoryCleared reports if the "payment_history" edge to the PaymentHistory entity was cleared.
func (m *ClassMutation) PaymentHistoryCleared() bool {
	return m.clearedpayment_history
}

// PaymentHistoryID returns the "payment_history" edge ID in the mutation.
func (m *ClassMutation) PaymentHistoryID() (id uuid.UUID, exists bool) {
	if m.payment_history != nil {
		return *m.payment_history, true
	}
	return
}

// PaymentHistoryIDs returns the "payment_history" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentHistoryID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) PaymentHistoryIDs() (ids []uuid.UUID) {
	if id := m.payment_history; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaymentHistory resets all changes to the "payment_history" edge.
func (m *ClassMutation) ResetPaymentHistory() {
	m.payment_history = nil
	m.clearedpayment_history = false
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.review_avaliable != nil {
		fields = append(fields, class.FieldReviewAvaliable)
	}
	if m.total_hour != nil {
		fields = append(fields, class.FieldTotalHour)
	}
	if m.success_hour != nil {
		fields = append(fields, class.FieldSuccessHour)
	}
	if m.status != nil {
		fields = append(fields, class.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldReviewAvaliable:
		return m.ReviewAvaliable()
	case class.FieldTotalHour:
		return m.TotalHour()
	case class.FieldSuccessHour:
		return m.SuccessHour()
	case class.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldReviewAvaliable:
		return m.OldReviewAvaliable(ctx)
	case class.FieldTotalHour:
		return m.OldTotalHour(ctx)
	case class.FieldSuccessHour:
		return m.OldSuccessHour(ctx)
	case class.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldReviewAvaliable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewAvaliable(v)
		return nil
	case class.FieldTotalHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalHour(v)
		return nil
	case class.FieldSuccessHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessHour(v)
		return nil
	case class.FieldStatus:
		v, ok := value.(class.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_hour != nil {
		fields = append(fields, class.FieldTotalHour)
	}
	if m.addsuccess_hour != nil {
		fields = append(fields, class.FieldSuccessHour)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case class.FieldTotalHour:
		return m.AddedTotalHour()
	case class.FieldSuccessHour:
		return m.AddedSuccessHour()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	case class.FieldTotalHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalHour(v)
		return nil
	case class.FieldSuccessHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessHour(v)
		return nil
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldReviewAvaliable:
		m.ResetReviewAvaliable()
		return nil
	case class.FieldTotalHour:
		m.ResetTotalHour()
		return nil
	case class.FieldSuccessHour:
		m.ResetSuccessHour()
		return nil
	case class.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.match != nil {
		edges = append(edges, class.EdgeMatch)
	}
	if m.schedule != nil {
		edges = append(edges, class.EdgeSchedule)
	}
	if m.payment_history != nil {
		edges = append(edges, class.EdgePaymentHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.match))
		for id := range m.match {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgePaymentHistory:
		if id := m.payment_history; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmatch != nil {
		edges = append(edges, class.EdgeMatch)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.removedmatch))
		for id := range m.removedmatch {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmatch {
		edges = append(edges, class.EdgeMatch)
	}
	if m.clearedschedule {
		edges = append(edges, class.EdgeSchedule)
	}
	if m.clearedpayment_history {
		edges = append(edges, class.EdgePaymentHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeMatch:
		return m.clearedmatch
	case class.EdgeSchedule:
		return m.clearedschedule
	case class.EdgePaymentHistory:
		return m.clearedpayment_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	case class.EdgeSchedule:
		m.ClearSchedule()
		return nil
	case class.EdgePaymentHistory:
		m.ClearPaymentHistory()
		return nil
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeMatch:
		m.ResetMatch()
		return nil
	case class.EdgeSchedule:
		m.ResetSchedule()
		return nil
	case class.EdgePaymentHistory:
		m.ResetPaymentHistory()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	title                *string
	subject              *string
	topic                *string
	estimated_time       *int
	addestimated_time    *int
	description          *string
	price_per_hour       *int
	addprice_per_hour    *int
	level                *course.Level
	course_picture_url   *string
	clearedFields        map[string]struct{}
	review_course        map[int]struct{}
	removedreview_course map[int]struct{}
	clearedreview_course bool
	match                map[uuid.UUID]struct{}
	removedmatch         map[uuid.UUID]struct{}
	clearedmatch         bool
	tutor                *uuid.UUID
	clearedtutor         bool
	done                 bool
	oldValue             func(context.Context) (*Course, error)
	predicates           []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id uuid.UUID) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Course entities.
func (m *CourseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *CourseMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseMutation) ResetTitle() {
	m.title = nil
}

// SetSubject sets the "subject" field.
func (m *CourseMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *CourseMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *CourseMutation) ResetSubject() {
	m.subject = nil
}

// SetTopic sets the "topic" field.
func (m *CourseMutation) SetTopic(s string) {
	m.topic = &s
}

// Topic returns the value of the "topic" field in the mutation.
func (m *CourseMutation) Topic() (r string, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic returns the old "topic" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTopic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic: %w", err)
	}
	return oldValue.Topic, nil
}

// ResetTopic resets all changes to the "topic" field.
func (m *CourseMutation) ResetTopic() {
	m.topic = nil
}

// SetEstimatedTime sets the "estimated_time" field.
func (m *CourseMutation) SetEstimatedTime(i int) {
	m.estimated_time = &i
	m.addestimated_time = nil
}

// EstimatedTime returns the value of the "estimated_time" field in the mutation.
func (m *CourseMutation) EstimatedTime() (r int, exists bool) {
	v := m.estimated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedTime returns the old "estimated_time" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldEstimatedTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedTime: %w", err)
	}
	return oldValue.EstimatedTime, nil
}

// AddEstimatedTime adds i to the "estimated_time" field.
func (m *CourseMutation) AddEstimatedTime(i int) {
	if m.addestimated_time != nil {
		*m.addestimated_time += i
	} else {
		m.addestimated_time = &i
	}
}

// AddedEstimatedTime returns the value that was added to the "estimated_time" field in this mutation.
func (m *CourseMutation) AddedEstimatedTime() (r int, exists bool) {
	v := m.addestimated_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetEstimatedTime resets all changes to the "estimated_time" field.
func (m *CourseMutation) ResetEstimatedTime() {
	m.estimated_time = nil
	m.addestimated_time = nil
}

// SetDescription sets the "description" field.
func (m *CourseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CourseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CourseMutation) ResetDescription() {
	m.description = nil
}

// SetPricePerHour sets the "price_per_hour" field.
func (m *CourseMutation) SetPricePerHour(i int) {
	m.price_per_hour = &i
	m.addprice_per_hour = nil
}

// PricePerHour returns the value of the "price_per_hour" field in the mutation.
func (m *CourseMutation) PricePerHour() (r int, exists bool) {
	v := m.price_per_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePerHour returns the old "price_per_hour" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldPricePerHour(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePerHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePerHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePerHour: %w", err)
	}
	return oldValue.PricePerHour, nil
}

// AddPricePerHour adds i to the "price_per_hour" field.
func (m *CourseMutation) AddPricePerHour(i int) {
	if m.addprice_per_hour != nil {
		*m.addprice_per_hour += i
	} else {
		m.addprice_per_hour = &i
	}
}

// AddedPricePerHour returns the value that was added to the "price_per_hour" field in this mutation.
func (m *CourseMutation) AddedPricePerHour() (r int, exists bool) {
	v := m.addprice_per_hour
	if v == nil {
		return
	}
	return *v, true
}

// ResetPricePerHour resets all changes to the "price_per_hour" field.
func (m *CourseMutation) ResetPricePerHour() {
	m.price_per_hour = nil
	m.addprice_per_hour = nil
}

// SetLevel sets the "level" field.
func (m *CourseMutation) SetLevel(c course.Level) {
	m.level = &c
}

// Level returns the value of the "level" field in the mutation.
func (m *CourseMutation) Level() (r course.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldLevel(ctx context.Context) (v course.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ClearLevel clears the value of the "level" field.
func (m *CourseMutation) ClearLevel() {
	m.level = nil
	m.clearedFields[course.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *CourseMutation) LevelCleared() bool {
	_, ok := m.clearedFields[course.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *CourseMutation) ResetLevel() {
	m.level = nil
	delete(m.clearedFields, course.FieldLevel)
}

// SetCoursePictureURL sets the "course_picture_url" field.
func (m *CourseMutation) SetCoursePictureURL(s string) {
	m.course_picture_url = &s
}

// CoursePictureURL returns the value of the "course_picture_url" field in the mutation.
func (m *CourseMutation) CoursePictureURL() (r string, exists bool) {
	v := m.course_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoursePictureURL returns the old "course_picture_url" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCoursePictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoursePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoursePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoursePictureURL: %w", err)
	}
	return oldValue.CoursePictureURL, nil
}

// ClearCoursePictureURL clears the value of the "course_picture_url" field.
func (m *CourseMutation) ClearCoursePictureURL() {
	m.course_picture_url = nil
	m.clearedFields[course.FieldCoursePictureURL] = struct{}{}
}

// CoursePictureURLCleared returns if the "course_picture_url" field was cleared in this mutation.
func (m *CourseMutation) CoursePictureURLCleared() bool {
	_, ok := m.clearedFields[course.FieldCoursePictureURL]
	return ok
}

// ResetCoursePictureURL resets all changes to the "course_picture_url" field.
func (m *CourseMutation) ResetCoursePictureURL() {
	m.course_picture_url = nil
	delete(m.clearedFields, course.FieldCoursePictureURL)
}

// AddReviewCourseIDs adds the "review_course" edge to the ReviewCourse entity by ids.
func (m *CourseMutation) AddReviewCourseIDs(ids ...int) {
	if m.review_course == nil {
		m.review_course = make(map[int]struct{})
	}
	for i := range ids {
		m.review_course[ids[i]] = struct{}{}
	}
}

// ClearReviewCourse clears the "review_course" edge to the ReviewCourse entity.
func (m *CourseMutation) ClearReviewCourse() {
	m.clearedreview_course = true
}

// ReviewCourseCleared reports if the "review_course" edge to the ReviewCourse entity was cleared.
func (m *CourseMutation) ReviewCourseCleared() bool {
	return m.clearedreview_course
}

// RemoveReviewCourseIDs removes the "review_course" edge to the ReviewCourse entity by IDs.
func (m *CourseMutation) RemoveReviewCourseIDs(ids ...int) {
	if m.removedreview_course == nil {
		m.removedreview_course = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.review_course, ids[i])
		m.removedreview_course[ids[i]] = struct{}{}
	}
}

// RemovedReviewCourse returns the removed IDs of the "review_course" edge to the ReviewCourse entity.
func (m *CourseMutation) RemovedReviewCourseIDs() (ids []int) {
	for id := range m.removedreview_course {
		ids = append(ids, id)
	}
	return
}

// ReviewCourseIDs returns the "review_course" edge IDs in the mutation.
func (m *CourseMutation) ReviewCourseIDs() (ids []int) {
	for id := range m.review_course {
		ids = append(ids, id)
	}
	return
}

// ResetReviewCourse resets all changes to the "review_course" edge.
func (m *CourseMutation) ResetReviewCourse() {
	m.review_course = nil
	m.clearedreview_course = false
	m.removedreview_course = nil
}

// AddMatchIDs adds the "match" edge to the Match entity by ids.
func (m *CourseMutation) AddMatchIDs(ids ...uuid.UUID) {
	if m.match == nil {
		m.match = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.match[ids[i]] = struct{}{}
	}
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *CourseMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *CourseMutation) MatchCleared() bool {
	return m.clearedmatch
}

// RemoveMatchIDs removes the "match" edge to the Match entity by IDs.
func (m *CourseMutation) RemoveMatchIDs(ids ...uuid.UUID) {
	if m.removedmatch == nil {
		m.removedmatch = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.match, ids[i])
		m.removedmatch[ids[i]] = struct{}{}
	}
}

// RemovedMatch returns the removed IDs of the "match" edge to the Match entity.
func (m *CourseMutation) RemovedMatchIDs() (ids []uuid.UUID) {
	for id := range m.removedmatch {
		ids = append(ids, id)
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
func (m *CourseMutation) MatchIDs() (ids []uuid.UUID) {
	for id := range m.match {
		ids = append(ids, id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *CourseMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
	m.removedmatch = nil
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *CourseMutation) SetTutorID(id uuid.UUID) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *CourseMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *CourseMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *CourseMutation) TutorID() (id uuid.UUID, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) TutorIDs() (ids []uuid.UUID) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *CourseMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, course.FieldTitle)
	}
	if m.subject != nil {
		fields = append(fields, course.FieldSubject)
	}
	if m.topic != nil {
		fields = append(fields, course.FieldTopic)
	}
	if m.estimated_time != nil {
		fields = append(fields, course.FieldEstimatedTime)
	}
	if m.description != nil {
		fields = append(fields, course.FieldDescription)
	}
	if m.price_per_hour != nil {
		fields = append(fields, course.FieldPricePerHour)
	}
	if m.level != nil {
		fields = append(fields, course.FieldLevel)
	}
	if m.course_picture_url != nil {
		fields = append(fields, course.FieldCoursePictureURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldTitle:
		return m.Title()
	case course.FieldSubject:
		return m.Subject()
	case course.FieldTopic:
		return m.Topic()
	case course.FieldEstimatedTime:
		return m.EstimatedTime()
	case course.FieldDescription:
		return m.Description()
	case course.FieldPricePerHour:
		return m.PricePerHour()
	case course.FieldLevel:
		return m.Level()
	case course.FieldCoursePictureURL:
		return m.CoursePictureURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldTitle:
		return m.OldTitle(ctx)
	case course.FieldSubject:
		return m.OldSubject(ctx)
	case course.FieldTopic:
		return m.OldTopic(ctx)
	case course.FieldEstimatedTime:
		return m.OldEstimatedTime(ctx)
	case course.FieldDescription:
		return m.OldDescription(ctx)
	case course.FieldPricePerHour:
		return m.OldPricePerHour(ctx)
	case course.FieldLevel:
		return m.OldLevel(ctx)
	case course.FieldCoursePictureURL:
		return m.OldCoursePictureURL(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case course.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case course.FieldTopic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic(v)
		return nil
	case course.FieldEstimatedTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedTime(v)
		return nil
	case course.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case course.FieldPricePerHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePerHour(v)
		return nil
	case course.FieldLevel:
		v, ok := value.(course.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case course.FieldCoursePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoursePictureURL(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	if m.addestimated_time != nil {
		fields = append(fields, course.FieldEstimatedTime)
	}
	if m.addprice_per_hour != nil {
		fields = append(fields, course.FieldPricePerHour)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case course.FieldEstimatedTime:
		return m.AddedEstimatedTime()
	case course.FieldPricePerHour:
		return m.AddedPricePerHour()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case course.FieldEstimatedTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedTime(v)
		return nil
	case course.FieldPricePerHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPricePerHour(v)
		return nil
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(course.FieldLevel) {
		fields = append(fields, course.FieldLevel)
	}
	if m.FieldCleared(course.FieldCoursePictureURL) {
		fields = append(fields, course.FieldCoursePictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	switch name {
	case course.FieldLevel:
		m.ClearLevel()
		return nil
	case course.FieldCoursePictureURL:
		m.ClearCoursePictureURL()
		return nil
	}
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldTitle:
		m.ResetTitle()
		return nil
	case course.FieldSubject:
		m.ResetSubject()
		return nil
	case course.FieldTopic:
		m.ResetTopic()
		return nil
	case course.FieldEstimatedTime:
		m.ResetEstimatedTime()
		return nil
	case course.FieldDescription:
		m.ResetDescription()
		return nil
	case course.FieldPricePerHour:
		m.ResetPricePerHour()
		return nil
	case course.FieldLevel:
		m.ResetLevel()
		return nil
	case course.FieldCoursePictureURL:
		m.ResetCoursePictureURL()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.review_course != nil {
		edges = append(edges, course.EdgeReviewCourse)
	}
	if m.match != nil {
		edges = append(edges, course.EdgeMatch)
	}
	if m.tutor != nil {
		edges = append(edges, course.EdgeTutor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeReviewCourse:
		ids := make([]ent.Value, 0, len(m.review_course))
		for id := range m.review_course {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.match))
		for id := range m.match {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreview_course != nil {
		edges = append(edges, course.EdgeReviewCourse)
	}
	if m.removedmatch != nil {
		edges = append(edges, course.EdgeMatch)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeReviewCourse:
		ids := make([]ent.Value, 0, len(m.removedreview_course))
		for id := range m.removedreview_course {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.removedmatch))
		for id := range m.removedmatch {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreview_course {
		edges = append(edges, course.EdgeReviewCourse)
	}
	if m.clearedmatch {
		edges = append(edges, course.EdgeMatch)
	}
	if m.clearedtutor {
		edges = append(edges, course.EdgeTutor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeReviewCourse:
		return m.clearedreview_course
	case course.EdgeMatch:
		return m.clearedmatch
	case course.EdgeTutor:
		return m.clearedtutor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeTutor:
		m.ClearTutor()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeReviewCourse:
		m.ResetReviewCourse()
		return nil
	case course.EdgeMatch:
		m.ResetMatch()
		return nil
	case course.EdgeTutor:
		m.ResetTutor()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// IssueReportMutation represents an operation that mutates the IssueReport nodes in the graph.
type IssueReportMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	title         *string
	description   *string
	contact       *string
	report_date   *time.Time
	status        *issuereport.Status
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IssueReport, error)
	predicates    []predicate.IssueReport
}

var _ ent.Mutation = (*IssueReportMutation)(nil)

// issuereportOption allows management of the mutation configuration using functional options.
type issuereportOption func(*IssueReportMutation)

// newIssueReportMutation creates new mutation for the IssueReport entity.
func newIssueReportMutation(c config, op Op, opts ...issuereportOption) *IssueReportMutation {
	m := &IssueReportMutation{
		config:        c,
		op:            op,
		typ:           TypeIssueReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssueReportID sets the ID field of the mutation.
func withIssueReportID(id uuid.UUID) issuereportOption {
	return func(m *IssueReportMutation) {
		var (
			err   error
			once  sync.Once
			value *IssueReport
		)
		m.oldValue = func(ctx context.Context) (*IssueReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IssueReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssueReport sets the old IssueReport of the mutation.
func withIssueReport(node *IssueReport) issuereportOption {
	return func(m *IssueReportMutation) {
		m.oldValue = func(context.Context) (*IssueReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssueReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssueReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IssueReport entities.
func (m *IssueReportMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssueReportMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssueReportMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IssueReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *IssueReportMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IssueReportMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IssueReportMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IssueReportMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IssueReportMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *IssueReportMutation) ResetDescription() {
	m.description = nil
}

// SetContact sets the "contact" field.
func (m *IssueReportMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the value of the "contact" field in the mutation.
func (m *IssueReportMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ResetContact resets all changes to the "contact" field.
func (m *IssueReportMutation) ResetContact() {
	m.contact = nil
}

// SetReportDate sets the "report_date" field.
func (m *IssueReportMutation) SetReportDate(t time.Time) {
	m.report_date = &t
}

// ReportDate returns the value of the "report_date" field in the mutation.
func (m *IssueReportMutation) ReportDate() (r time.Time, exists bool) {
	v := m.report_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReportDate returns the old "report_date" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldReportDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportDate: %w", err)
	}
	return oldValue.ReportDate, nil
}

// ResetReportDate resets all changes to the "report_date" field.
func (m *IssueReportMutation) ResetReportDate() {
	m.report_date = nil
}

// SetStatus sets the "status" field.
func (m *IssueReportMutation) SetStatus(i issuereport.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *IssueReportMutation) Status() (r issuereport.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldStatus(ctx context.Context) (v issuereport.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IssueReportMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the IssueReportMutation builder.
func (m *IssueReportMutation) Where(ps ...predicate.IssueReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssueReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssueReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IssueReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssueReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssueReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IssueReport).
func (m *IssueReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssueReportMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.title != nil {
		fields = append(fields, issuereport.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, issuereport.FieldDescription)
	}
	if m.contact != nil {
		fields = append(fields, issuereport.FieldContact)
	}
	if m.report_date != nil {
		fields = append(fields, issuereport.FieldReportDate)
	}
	if m.status != nil {
		fields = append(fields, issuereport.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssueReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case issuereport.FieldTitle:
		return m.Title()
	case issuereport.FieldDescription:
		return m.Description()
	case issuereport.FieldContact:
		return m.Contact()
	case issuereport.FieldReportDate:
		return m.ReportDate()
	case issuereport.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssueReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case issuereport.FieldTitle:
		return m.OldTitle(ctx)
	case issuereport.FieldDescription:
		return m.OldDescription(ctx)
	case issuereport.FieldContact:
		return m.OldContact(ctx)
	case issuereport.FieldReportDate:
		return m.OldReportDate(ctx)
	case issuereport.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown IssueReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case issuereport.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case issuereport.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case issuereport.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case issuereport.FieldReportDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportDate(v)
		return nil
	case issuereport.FieldStatus:
		v, ok := value.(issuereport.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown IssueReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssueReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssueReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IssueReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssueReportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssueReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssueReportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IssueReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssueReportMutation) ResetField(name string) error {
	switch name {
	case issuereport.FieldTitle:
		m.ResetTitle()
		return nil
	case issuereport.FieldDescription:
		m.ResetDescription()
		return nil
	case issuereport.FieldContact:
		m.ResetContact()
		return nil
	case issuereport.FieldReportDate:
		m.ResetReportDate()
		return nil
	case issuereport.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown IssueReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssueReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssueReportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssueReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssueReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssueReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssueReportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssueReportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IssueReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssueReportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IssueReport edge %s", name)
}

// MatchMutation represents an operation that mutates the Match nodes in the graph.
type MatchMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	clearedFields  map[string]struct{}
	student        *uuid.UUID
	clearedstudent bool
	course         map[uuid.UUID]struct{}
	removedcourse  map[uuid.UUID]struct{}
	clearedcourse  bool
	class          map[uuid.UUID]struct{}
	removedclass   map[uuid.UUID]struct{}
	clearedclass   bool
	done           bool
	oldValue       func(context.Context) (*Match, error)
	predicates     []predicate.Match
}

var _ ent.Mutation = (*MatchMutation)(nil)

// matchOption allows management of the mutation configuration using functional options.
type matchOption func(*MatchMutation)

// newMatchMutation creates new mutation for the Match entity.
func newMatchMutation(c config, op Op, opts ...matchOption) *MatchMutation {
	m := &MatchMutation{
		config:        c,
		op:            op,
		typ:           TypeMatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchID sets the ID field of the mutation.
func withMatchID(id uuid.UUID) matchOption {
	return func(m *MatchMutation) {
		var (
			err   error
			once  sync.Once
			value *Match
		)
		m.oldValue = func(ctx context.Context) (*Match, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Match.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatch sets the old Match of the mutation.
func withMatch(node *Match) matchOption {
	return func(m *MatchMutation) {
		m.oldValue = func(context.Context) (*Match, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Match entities.
func (m *MatchMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Match.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *MatchMutation) SetStudentID(id uuid.UUID) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *MatchMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *MatchMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *MatchMutation) StudentID() (id uuid.UUID, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *MatchMutation) StudentIDs() (ids []uuid.UUID) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *MatchMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// AddCourseIDs adds the "course" edge to the Course entity by ids.
func (m *MatchMutation) AddCourseIDs(ids ...uuid.UUID) {
	if m.course == nil {
		m.course = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *MatchMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *MatchMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the Course entity by IDs.
func (m *MatchMutation) RemoveCourseIDs(ids ...uuid.UUID) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course, ids[i])
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the Course entity.
func (m *MatchMutation) RemovedCourseIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *MatchMutation) CourseIDs() (ids []uuid.UUID) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *MatchMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// AddClasIDs adds the "class" edge to the Class entity by ids.
func (m *MatchMutation) AddClasIDs(ids ...uuid.UUID) {
	if m.class == nil {
		m.class = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.class[ids[i]] = struct{}{}
	}
}

// ClearClass clears the "class" edge to the Class entity.
func (m *MatchMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *MatchMutation) ClassCleared() bool {
	return m.clearedclass
}

// RemoveClasIDs removes the "class" edge to the Class entity by IDs.
func (m *MatchMutation) RemoveClasIDs(ids ...uuid.UUID) {
	if m.removedclass == nil {
		m.removedclass = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.class, ids[i])
		m.removedclass[ids[i]] = struct{}{}
	}
}

// RemovedClass returns the removed IDs of the "class" edge to the Class entity.
func (m *MatchMutation) RemovedClassIDs() (ids []uuid.UUID) {
	for id := range m.removedclass {
		ids = append(ids, id)
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
func (m *MatchMutation) ClassIDs() (ids []uuid.UUID) {
	for id := range m.class {
		ids = append(ids, id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *MatchMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
	m.removedclass = nil
}

// Where appends a list predicates to the MatchMutation builder.
func (m *MatchMutation) Where(ps ...predicate.Match) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Match, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Match).
func (m *MatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Match field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Match numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Match nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.student != nil {
		edges = append(edges, match.EdgeStudent)
	}
	if m.course != nil {
		edges = append(edges, match.EdgeCourse)
	}
	if m.class != nil {
		edges = append(edges, match.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case match.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case match.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case match.EdgeClass:
		ids := make([]ent.Value, 0, len(m.class))
		for id := range m.class {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcourse != nil {
		edges = append(edges, match.EdgeCourse)
	}
	if m.removedclass != nil {
		edges = append(edges, match.EdgeClass)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case match.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	case match.EdgeClass:
		ids := make([]ent.Value, 0, len(m.removedclass))
		for id := range m.removedclass {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstudent {
		edges = append(edges, match.EdgeStudent)
	}
	if m.clearedcourse {
		edges = append(edges, match.EdgeCourse)
	}
	if m.clearedclass {
		edges = append(edges, match.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchMutation) EdgeCleared(name string) bool {
	switch name {
	case match.EdgeStudent:
		return m.clearedstudent
	case match.EdgeCourse:
		return m.clearedcourse
	case match.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchMutation) ClearEdge(name string) error {
	switch name {
	case match.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown Match unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchMutation) ResetEdge(name string) error {
	switch name {
	case match.EdgeStudent:
		m.ResetStudent()
		return nil
	case match.EdgeCourse:
		m.ResetCourse()
		return nil
	case match.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Match edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	qr_picture_url         *string
	clearedFields          map[string]struct{}
	user                   *uuid.UUID
	cleareduser            bool
	payment_history        map[uuid.UUID]struct{}
	removedpayment_history map[uuid.UUID]struct{}
	clearedpayment_history bool
	done                   bool
	oldValue               func(context.Context) (*Payment, error)
	predicates             []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id uuid.UUID) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payment entities.
func (m *PaymentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQrPictureURL sets the "qr_picture_url" field.
func (m *PaymentMutation) SetQrPictureURL(s string) {
	m.qr_picture_url = &s
}

// QrPictureURL returns the value of the "qr_picture_url" field in the mutation.
func (m *PaymentMutation) QrPictureURL() (r string, exists bool) {
	v := m.qr_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldQrPictureURL returns the old "qr_picture_url" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldQrPictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrPictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrPictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrPictureURL: %w", err)
	}
	return oldValue.QrPictureURL, nil
}

// ClearQrPictureURL clears the value of the "qr_picture_url" field.
func (m *PaymentMutation) ClearQrPictureURL() {
	m.qr_picture_url = nil
	m.clearedFields[payment.FieldQrPictureURL] = struct{}{}
}

// QrPictureURLCleared returns if the "qr_picture_url" field was cleared in this mutation.
func (m *PaymentMutation) QrPictureURLCleared() bool {
	_, ok := m.clearedFields[payment.FieldQrPictureURL]
	return ok
}

// ResetQrPictureURL resets all changes to the "qr_picture_url" field.
func (m *PaymentMutation) ResetQrPictureURL() {
	m.qr_picture_url = nil
	delete(m.clearedFields, payment.FieldQrPictureURL)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PaymentMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PaymentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PaymentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PaymentMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PaymentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddPaymentHistoryIDs adds the "payment_history" edge to the PaymentHistory entity by ids.
func (m *PaymentMutation) AddPaymentHistoryIDs(ids ...uuid.UUID) {
	if m.payment_history == nil {
		m.payment_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.payment_history[ids[i]] = struct{}{}
	}
}

// ClearPaymentHistory clears the "payment_history" edge to the PaymentHistory entity.
func (m *PaymentMutation) ClearPaymentHistory() {
	m.clearedpayment_history = true
}

// PaymentHistoryCleared reports if the "payment_history" edge to the PaymentHistory entity was cleared.
func (m *PaymentMutation) PaymentHistoryCleared() bool {
	return m.clearedpayment_history
}

// RemovePaymentHistoryIDs removes the "payment_history" edge to the PaymentHistory entity by IDs.
func (m *PaymentMutation) RemovePaymentHistoryIDs(ids ...uuid.UUID) {
	if m.removedpayment_history == nil {
		m.removedpayment_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.payment_history, ids[i])
		m.removedpayment_history[ids[i]] = struct{}{}
	}
}

// RemovedPaymentHistory returns the removed IDs of the "payment_history" edge to the PaymentHistory entity.
func (m *PaymentMutation) RemovedPaymentHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedpayment_history {
		ids = append(ids, id)
	}
	return
}

// PaymentHistoryIDs returns the "payment_history" edge IDs in the mutation.
func (m *PaymentMutation) PaymentHistoryIDs() (ids []uuid.UUID) {
	for id := range m.payment_history {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentHistory resets all changes to the "payment_history" edge.
func (m *PaymentMutation) ResetPaymentHistory() {
	m.payment_history = nil
	m.clearedpayment_history = false
	m.removedpayment_history = nil
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.qr_picture_url != nil {
		fields = append(fields, payment.FieldQrPictureURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldQrPictureURL:
		return m.QrPictureURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldQrPictureURL:
		return m.OldQrPictureURL(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldQrPictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrPictureURL(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment.FieldQrPictureURL) {
		fields = append(fields, payment.FieldQrPictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	switch name {
	case payment.FieldQrPictureURL:
		m.ClearQrPictureURL()
		return nil
	}
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldQrPictureURL:
		m.ResetQrPictureURL()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, payment.EdgeUser)
	}
	if m.payment_history != nil {
		edges = append(edges, payment.EdgePaymentHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgePaymentHistory:
		ids := make([]ent.Value, 0, len(m.payment_history))
		for id := range m.payment_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpayment_history != nil {
		edges = append(edges, payment.EdgePaymentHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgePaymentHistory:
		ids := make([]ent.Value, 0, len(m.removedpayment_history))
		for id := range m.removedpayment_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, payment.EdgeUser)
	}
	if m.clearedpayment_history {
		edges = append(edges, payment.EdgePaymentHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeUser:
		return m.cleareduser
	case payment.EdgePaymentHistory:
		return m.clearedpayment_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeUser:
		m.ResetUser()
		return nil
	case payment.EdgePaymentHistory:
		m.ResetPaymentHistory()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PaymentHistoryMutation represents an operation that mutates the PaymentHistory nodes in the graph.
type PaymentHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	clearedFields  map[string]struct{}
	class          map[uuid.UUID]struct{}
	removedclass   map[uuid.UUID]struct{}
	clearedclass   bool
	user           *uuid.UUID
	cleareduser    bool
	payment        *uuid.UUID
	clearedpayment bool
	done           bool
	oldValue       func(context.Context) (*PaymentHistory, error)
	predicates     []predicate.PaymentHistory
}

var _ ent.Mutation = (*PaymentHistoryMutation)(nil)

// paymenthistoryOption allows management of the mutation configuration using functional options.
type paymenthistoryOption func(*PaymentHistoryMutation)

// newPaymentHistoryMutation creates new mutation for the PaymentHistory entity.
func newPaymentHistoryMutation(c config, op Op, opts ...paymenthistoryOption) *PaymentHistoryMutation {
	m := &PaymentHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentHistoryID sets the ID field of the mutation.
func withPaymentHistoryID(id uuid.UUID) paymenthistoryOption {
	return func(m *PaymentHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentHistory
		)
		m.oldValue = func(ctx context.Context) (*PaymentHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentHistory sets the old PaymentHistory of the mutation.
func withPaymentHistory(node *PaymentHistory) paymenthistoryOption {
	return func(m *PaymentHistoryMutation) {
		m.oldValue = func(context.Context) (*PaymentHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentHistory entities.
func (m *PaymentHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddClasIDs adds the "class" edge to the Class entity by ids.
func (m *PaymentHistoryMutation) AddClasIDs(ids ...uuid.UUID) {
	if m.class == nil {
		m.class = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.class[ids[i]] = struct{}{}
	}
}

// ClearClass clears the "class" edge to the Class entity.
func (m *PaymentHistoryMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *PaymentHistoryMutation) ClassCleared() bool {
	return m.clearedclass
}

// RemoveClasIDs removes the "class" edge to the Class entity by IDs.
func (m *PaymentHistoryMutation) RemoveClasIDs(ids ...uuid.UUID) {
	if m.removedclass == nil {
		m.removedclass = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.class, ids[i])
		m.removedclass[ids[i]] = struct{}{}
	}
}

// RemovedClass returns the removed IDs of the "class" edge to the Class entity.
func (m *PaymentHistoryMutation) RemovedClassIDs() (ids []uuid.UUID) {
	for id := range m.removedclass {
		ids = append(ids, id)
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
func (m *PaymentHistoryMutation) ClassIDs() (ids []uuid.UUID) {
	for id := range m.class {
		ids = append(ids, id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *PaymentHistoryMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
	m.removedclass = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PaymentHistoryMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PaymentHistoryMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PaymentHistoryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PaymentHistoryMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PaymentHistoryMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PaymentHistoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPaymentID sets the "payment" edge to the Payment entity by id.
func (m *PaymentHistoryMutation) SetPaymentID(id uuid.UUID) {
	m.payment = &id
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *PaymentHistoryMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *PaymentHistoryMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// PaymentID returns the "payment" edge ID in the mutation.
func (m *PaymentHistoryMutation) PaymentID() (id uuid.UUID, exists bool) {
	if m.payment != nil {
		return *m.payment, true
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentID instead. It exists only for internal usage by the builders.
func (m *PaymentHistoryMutation) PaymentIDs() (ids []uuid.UUID) {
	if id := m.payment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *PaymentHistoryMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
}

// Where appends a list predicates to the PaymentHistoryMutation builder.
func (m *PaymentHistoryMutation) Where(ps ...predicate.PaymentHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentHistory).
func (m *PaymentHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentHistoryMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentHistoryMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PaymentHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentHistoryMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PaymentHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaymentHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentHistoryMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PaymentHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.class != nil {
		edges = append(edges, paymenthistory.EdgeClass)
	}
	if m.user != nil {
		edges = append(edges, paymenthistory.EdgeUser)
	}
	if m.payment != nil {
		edges = append(edges, paymenthistory.EdgePayment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymenthistory.EdgeClass:
		ids := make([]ent.Value, 0, len(m.class))
		for id := range m.class {
			ids = append(ids, id)
		}
		return ids
	case paymenthistory.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case paymenthistory.EdgePayment:
		if id := m.payment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedclass != nil {
		edges = append(edges, paymenthistory.EdgeClass)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentHistoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case paymenthistory.EdgeClass:
		ids := make([]ent.Value, 0, len(m.removedclass))
		for id := range m.removedclass {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclass {
		edges = append(edges, paymenthistory.EdgeClass)
	}
	if m.cleareduser {
		edges = append(edges, paymenthistory.EdgeUser)
	}
	if m.clearedpayment {
		edges = append(edges, paymenthistory.EdgePayment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case paymenthistory.EdgeClass:
		return m.clearedclass
	case paymenthistory.EdgeUser:
		return m.cleareduser
	case paymenthistory.EdgePayment:
		return m.clearedpayment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentHistoryMutation) ClearEdge(name string) error {
	switch name {
	case paymenthistory.EdgeUser:
		m.ClearUser()
		return nil
	case paymenthistory.EdgePayment:
		m.ClearPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentHistoryMutation) ResetEdge(name string) error {
	switch name {
	case paymenthistory.EdgeClass:
		m.ResetClass()
		return nil
	case paymenthistory.EdgeUser:
		m.ResetUser()
		return nil
	case paymenthistory.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentHistory edge %s", name)
}

// ReviewCourseMutation represents an operation that mutates the ReviewCourse nodes in the graph.
type ReviewCourseMutation struct {
	config
	op             Op
	typ            string
	id             *int
	score          *float32
	addscore       *float32
	review_msg     *string
	clearedFields  map[string]struct{}
	course         map[uuid.UUID]struct{}
	removedcourse  map[uuid.UUID]struct{}
	clearedcourse  bool
	student        map[uuid.UUID]struct{}
	removedstudent map[uuid.UUID]struct{}
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*ReviewCourse, error)
	predicates     []predicate.ReviewCourse
}

var _ ent.Mutation = (*ReviewCourseMutation)(nil)

// reviewcourseOption allows management of the mutation configuration using functional options.
type reviewcourseOption func(*ReviewCourseMutation)

// newReviewCourseMutation creates new mutation for the ReviewCourse entity.
func newReviewCourseMutation(c config, op Op, opts ...reviewcourseOption) *ReviewCourseMutation {
	m := &ReviewCourseMutation{
		config:        c,
		op:            op,
		typ:           TypeReviewCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewCourseID sets the ID field of the mutation.
func withReviewCourseID(id int) reviewcourseOption {
	return func(m *ReviewCourseMutation) {
		var (
			err   error
			once  sync.Once
			value *ReviewCourse
		)
		m.oldValue = func(ctx context.Context) (*ReviewCourse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReviewCourse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReviewCourse sets the old ReviewCourse of the mutation.
func withReviewCourse(node *ReviewCourse) reviewcourseOption {
	return func(m *ReviewCourseMutation) {
		m.oldValue = func(context.Context) (*ReviewCourse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewCourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewCourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewCourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewCourseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReviewCourse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScore sets the "score" field.
func (m *ReviewCourseMutation) SetScore(f float32) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ReviewCourseMutation) Score() (r float32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ReviewCourse entity.
// If the ReviewCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCourseMutation) OldScore(ctx context.Context) (v *float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *ReviewCourseMutation) AddScore(f float32) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ReviewCourseMutation) AddedScore() (r float32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *ReviewCourseMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[reviewcourse.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ReviewCourseMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[reviewcourse.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ReviewCourseMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, reviewcourse.FieldScore)
}

// SetReviewMsg sets the "review_msg" field.
func (m *ReviewCourseMutation) SetReviewMsg(s string) {
	m.review_msg = &s
}

// ReviewMsg returns the value of the "review_msg" field in the mutation.
func (m *ReviewCourseMutation) ReviewMsg() (r string, exists bool) {
	v := m.review_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewMsg returns the old "review_msg" field's value of the ReviewCourse entity.
// If the ReviewCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCourseMutation) OldReviewMsg(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewMsg: %w", err)
	}
	return oldValue.ReviewMsg, nil
}

// ClearReviewMsg clears the value of the "review_msg" field.
func (m *ReviewCourseMutation) ClearReviewMsg() {
	m.review_msg = nil
	m.clearedFields[reviewcourse.FieldReviewMsg] = struct{}{}
}

// ReviewMsgCleared returns if the "review_msg" field was cleared in this mutation.
func (m *ReviewCourseMutation) ReviewMsgCleared() bool {
	_, ok := m.clearedFields[reviewcourse.FieldReviewMsg]
	return ok
}

// ResetReviewMsg resets all changes to the "review_msg" field.
func (m *ReviewCourseMutation) ResetReviewMsg() {
	m.review_msg = nil
	delete(m.clearedFields, reviewcourse.FieldReviewMsg)
}

// AddCourseIDs adds the "course" edge to the Course entity by ids.
func (m *ReviewCourseMutation) AddCourseIDs(ids ...uuid.UUID) {
	if m.course == nil {
		m.course = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *ReviewCourseMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *ReviewCourseMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the Course entity by IDs.
func (m *ReviewCourseMutation) RemoveCourseIDs(ids ...uuid.UUID) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course, ids[i])
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the Course entity.
func (m *ReviewCourseMutation) RemovedCourseIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *ReviewCourseMutation) CourseIDs() (ids []uuid.UUID) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ReviewCourseMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// AddStudentIDs adds the "student" edge to the Student entity by ids.
func (m *ReviewCourseMutation) AddStudentIDs(ids ...uuid.UUID) {
	if m.student == nil {
		m.student = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *ReviewCourseMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *ReviewCourseMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the Student entity by IDs.
func (m *ReviewCourseMutation) RemoveStudentIDs(ids ...uuid.UUID) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the Student entity.
func (m *ReviewCourseMutation) RemovedStudentIDs() (ids []uuid.UUID) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *ReviewCourseMutation) StudentIDs() (ids []uuid.UUID) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ReviewCourseMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// Where appends a list predicates to the ReviewCourseMutation builder.
func (m *ReviewCourseMutation) Where(ps ...predicate.ReviewCourse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewCourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewCourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReviewCourse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewCourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewCourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReviewCourse).
func (m *ReviewCourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewCourseMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.score != nil {
		fields = append(fields, reviewcourse.FieldScore)
	}
	if m.review_msg != nil {
		fields = append(fields, reviewcourse.FieldReviewMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewCourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reviewcourse.FieldScore:
		return m.Score()
	case reviewcourse.FieldReviewMsg:
		return m.ReviewMsg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewCourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reviewcourse.FieldScore:
		return m.OldScore(ctx)
	case reviewcourse.FieldReviewMsg:
		return m.OldReviewMsg(ctx)
	}
	return nil, fmt.Errorf("unknown ReviewCourse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewCourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reviewcourse.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case reviewcourse.FieldReviewMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewMsg(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewCourseMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, reviewcourse.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewCourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reviewcourse.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewCourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reviewcourse.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewCourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reviewcourse.FieldScore) {
		fields = append(fields, reviewcourse.FieldScore)
	}
	if m.FieldCleared(reviewcourse.FieldReviewMsg) {
		fields = append(fields, reviewcourse.FieldReviewMsg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewCourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewCourseMutation) ClearField(name string) error {
	switch name {
	case reviewcourse.FieldScore:
		m.ClearScore()
		return nil
	case reviewcourse.FieldReviewMsg:
		m.ClearReviewMsg()
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewCourseMutation) ResetField(name string) error {
	switch name {
	case reviewcourse.FieldScore:
		m.ResetScore()
		return nil
	case reviewcourse.FieldReviewMsg:
		m.ResetReviewMsg()
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewCourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.course != nil {
		edges = append(edges, reviewcourse.EdgeCourse)
	}
	if m.student != nil {
		edges = append(edges, reviewcourse.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewCourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reviewcourse.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case reviewcourse.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewCourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcourse != nil {
		edges = append(edges, reviewcourse.EdgeCourse)
	}
	if m.removedstudent != nil {
		edges = append(edges, reviewcourse.EdgeStudent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewCourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case reviewcourse.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	case reviewcourse.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewCourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcourse {
		edges = append(edges, reviewcourse.EdgeCourse)
	}
	if m.clearedstudent {
		edges = append(edges, reviewcourse.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewCourseMutation) EdgeCleared(name string) bool {
	switch name {
	case reviewcourse.EdgeCourse:
		return m.clearedcourse
	case reviewcourse.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewCourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ReviewCourse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewCourseMutation) ResetEdge(name string) error {
	switch name {
	case reviewcourse.EdgeCourse:
		m.ResetCourse()
		return nil
	case reviewcourse.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse edge %s", name)
}

// ReviewTutorMutation represents an operation that mutates the ReviewTutor nodes in the graph.
type ReviewTutorMutation struct {
	config
	op             Op
	typ            string
	id             *int
	score          *float32
	addscore       *float32
	review_msg     *string
	clearedFields  map[string]struct{}
	tutor          map[uuid.UUID]struct{}
	removedtutor   map[uuid.UUID]struct{}
	clearedtutor   bool
	student        map[uuid.UUID]struct{}
	removedstudent map[uuid.UUID]struct{}
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*ReviewTutor, error)
	predicates     []predicate.ReviewTutor
}

var _ ent.Mutation = (*ReviewTutorMutation)(nil)

// reviewtutorOption allows management of the mutation configuration using functional options.
type reviewtutorOption func(*ReviewTutorMutation)

// newReviewTutorMutation creates new mutation for the ReviewTutor entity.
func newReviewTutorMutation(c config, op Op, opts ...reviewtutorOption) *ReviewTutorMutation {
	m := &ReviewTutorMutation{
		config:        c,
		op:            op,
		typ:           TypeReviewTutor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewTutorID sets the ID field of the mutation.
func withReviewTutorID(id int) reviewtutorOption {
	return func(m *ReviewTutorMutation) {
		var (
			err   error
			once  sync.Once
			value *ReviewTutor
		)
		m.oldValue = func(ctx context.Context) (*ReviewTutor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReviewTutor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReviewTutor sets the old ReviewTutor of the mutation.
func withReviewTutor(node *ReviewTutor) reviewtutorOption {
	return func(m *ReviewTutorMutation) {
		m.oldValue = func(context.Context) (*ReviewTutor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewTutorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewTutorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewTutorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewTutorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReviewTutor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScore sets the "score" field.
func (m *ReviewTutorMutation) SetScore(f float32) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ReviewTutorMutation) Score() (r float32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ReviewTutor entity.
// If the ReviewTutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewTutorMutation) OldScore(ctx context.Context) (v *float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *ReviewTutorMutation) AddScore(f float32) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ReviewTutorMutation) AddedScore() (r float32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *ReviewTutorMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[reviewtutor.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ReviewTutorMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[reviewtutor.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ReviewTutorMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, reviewtutor.FieldScore)
}

// SetReviewMsg sets the "review_msg" field.
func (m *ReviewTutorMutation) SetReviewMsg(s string) {
	m.review_msg = &s
}

// ReviewMsg returns the value of the "review_msg" field in the mutation.
func (m *ReviewTutorMutation) ReviewMsg() (r string, exists bool) {
	v := m.review_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewMsg returns the old "review_msg" field's value of the ReviewTutor entity.
// If the ReviewTutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewTutorMutation) OldReviewMsg(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewMsg: %w", err)
	}
	return oldValue.ReviewMsg, nil
}

// ClearReviewMsg clears the value of the "review_msg" field.
func (m *ReviewTutorMutation) ClearReviewMsg() {
	m.review_msg = nil
	m.clearedFields[reviewtutor.FieldReviewMsg] = struct{}{}
}

// ReviewMsgCleared returns if the "review_msg" field was cleared in this mutation.
func (m *ReviewTutorMutation) ReviewMsgCleared() bool {
	_, ok := m.clearedFields[reviewtutor.FieldReviewMsg]
	return ok
}

// ResetReviewMsg resets all changes to the "review_msg" field.
func (m *ReviewTutorMutation) ResetReviewMsg() {
	m.review_msg = nil
	delete(m.clearedFields, reviewtutor.FieldReviewMsg)
}

// AddTutorIDs adds the "tutor" edge to the Tutor entity by ids.
func (m *ReviewTutorMutation) AddTutorIDs(ids ...uuid.UUID) {
	if m.tutor == nil {
		m.tutor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tutor[ids[i]] = struct{}{}
	}
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *ReviewTutorMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *ReviewTutorMutation) TutorCleared() bool {
	return m.clearedtutor
}

// RemoveTutorIDs removes the "tutor" edge to the Tutor entity by IDs.
func (m *ReviewTutorMutation) RemoveTutorIDs(ids ...uuid.UUID) {
	if m.removedtutor == nil {
		m.removedtutor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tutor, ids[i])
		m.removedtutor[ids[i]] = struct{}{}
	}
}

// RemovedTutor returns the removed IDs of the "tutor" edge to the Tutor entity.
func (m *ReviewTutorMutation) RemovedTutorIDs() (ids []uuid.UUID) {
	for id := range m.removedtutor {
		ids = append(ids, id)
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
func (m *ReviewTutorMutation) TutorIDs() (ids []uuid.UUID) {
	for id := range m.tutor {
		ids = append(ids, id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *ReviewTutorMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
	m.removedtutor = nil
}

// AddStudentIDs adds the "student" edge to the Student entity by ids.
func (m *ReviewTutorMutation) AddStudentIDs(ids ...uuid.UUID) {
	if m.student == nil {
		m.student = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *ReviewTutorMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *ReviewTutorMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the Student entity by IDs.
func (m *ReviewTutorMutation) RemoveStudentIDs(ids ...uuid.UUID) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the Student entity.
func (m *ReviewTutorMutation) RemovedStudentIDs() (ids []uuid.UUID) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *ReviewTutorMutation) StudentIDs() (ids []uuid.UUID) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ReviewTutorMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// Where appends a list predicates to the ReviewTutorMutation builder.
func (m *ReviewTutorMutation) Where(ps ...predicate.ReviewTutor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewTutorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewTutorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReviewTutor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewTutorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewTutorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReviewTutor).
func (m *ReviewTutorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewTutorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.score != nil {
		fields = append(fields, reviewtutor.FieldScore)
	}
	if m.review_msg != nil {
		fields = append(fields, reviewtutor.FieldReviewMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewTutorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reviewtutor.FieldScore:
		return m.Score()
	case reviewtutor.FieldReviewMsg:
		return m.ReviewMsg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewTutorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reviewtutor.FieldScore:
		return m.OldScore(ctx)
	case reviewtutor.FieldReviewMsg:
		return m.OldReviewMsg(ctx)
	}
	return nil, fmt.Errorf("unknown ReviewTutor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewTutorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reviewtutor.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case reviewtutor.FieldReviewMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewMsg(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewTutorMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, reviewtutor.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewTutorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reviewtutor.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewTutorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reviewtutor.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewTutorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reviewtutor.FieldScore) {
		fields = append(fields, reviewtutor.FieldScore)
	}
	if m.FieldCleared(reviewtutor.FieldReviewMsg) {
		fields = append(fields, reviewtutor.FieldReviewMsg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewTutorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewTutorMutation) ClearField(name string) error {
	switch name {
	case reviewtutor.FieldScore:
		m.ClearScore()
		return nil
	case reviewtutor.FieldReviewMsg:
		m.ClearReviewMsg()
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewTutorMutation) ResetField(name string) error {
	switch name {
	case reviewtutor.FieldScore:
		m.ResetScore()
		return nil
	case reviewtutor.FieldReviewMsg:
		m.ResetReviewMsg()
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewTutorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tutor != nil {
		edges = append(edges, reviewtutor.EdgeTutor)
	}
	if m.student != nil {
		edges = append(edges, reviewtutor.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewTutorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reviewtutor.EdgeTutor:
		ids := make([]ent.Value, 0, len(m.tutor))
		for id := range m.tutor {
			ids = append(ids, id)
		}
		return ids
	case reviewtutor.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewTutorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtutor != nil {
		edges = append(edges, reviewtutor.EdgeTutor)
	}
	if m.removedstudent != nil {
		edges = append(edges, reviewtutor.EdgeStudent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewTutorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case reviewtutor.EdgeTutor:
		ids := make([]ent.Value, 0, len(m.removedtutor))
		for id := range m.removedtutor {
			ids = append(ids, id)
		}
		return ids
	case reviewtutor.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewTutorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtutor {
		edges = append(edges, reviewtutor.EdgeTutor)
	}
	if m.clearedstudent {
		edges = append(edges, reviewtutor.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewTutorMutation) EdgeCleared(name string) bool {
	switch name {
	case reviewtutor.EdgeTutor:
		return m.clearedtutor
	case reviewtutor.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewTutorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ReviewTutor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewTutorMutation) ResetEdge(name string) error {
	switch name {
	case reviewtutor.EdgeTutor:
		m.ResetTutor()
		return nil
	case reviewtutor.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor edge %s", name)
}

// ScheduleMutation represents an operation that mutates the Schedule nodes in the graph.
type ScheduleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	day_0         *[24]bool
	day_1         *[24]bool
	day_2         *[24]bool
	day_3         *[24]bool
	day_4         *[24]bool
	day_5         *[24]bool
	day_6         *[24]bool
	clearedFields map[string]struct{}
	tutor         map[uuid.UUID]struct{}
	removedtutor  map[uuid.UUID]struct{}
	clearedtutor  bool
	class         map[uuid.UUID]struct{}
	removedclass  map[uuid.UUID]struct{}
	clearedclass  bool
	done          bool
	oldValue      func(context.Context) (*Schedule, error)
	predicates    []predicate.Schedule
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows management of the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for the Schedule entity.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the ID field of the mutation.
func withScheduleID(id uuid.UUID) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Schedule entities.
func (m *ScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Schedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDay0 sets the "day_0" field.
func (m *ScheduleMutation) SetDay0(b [24]bool) {
	m.day_0 = &b
}

// Day0 returns the value of the "day_0" field in the mutation.
func (m *ScheduleMutation) Day0() (r [24]bool, exists bool) {
	v := m.day_0
	if v == nil {
		return
	}
	return *v, true
}

// OldDay0 returns the old "day_0" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay0(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay0 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay0 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay0: %w", err)
	}
	return oldValue.Day0, nil
}

// ResetDay0 resets all changes to the "day_0" field.
func (m *ScheduleMutation) ResetDay0() {
	m.day_0 = nil
}

// SetDay1 sets the "day_1" field.
func (m *ScheduleMutation) SetDay1(b [24]bool) {
	m.day_1 = &b
}

// Day1 returns the value of the "day_1" field in the mutation.
func (m *ScheduleMutation) Day1() (r [24]bool, exists bool) {
	v := m.day_1
	if v == nil {
		return
	}
	return *v, true
}

// OldDay1 returns the old "day_1" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay1(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay1: %w", err)
	}
	return oldValue.Day1, nil
}

// ResetDay1 resets all changes to the "day_1" field.
func (m *ScheduleMutation) ResetDay1() {
	m.day_1 = nil
}

// SetDay2 sets the "day_2" field.
func (m *ScheduleMutation) SetDay2(b [24]bool) {
	m.day_2 = &b
}

// Day2 returns the value of the "day_2" field in the mutation.
func (m *ScheduleMutation) Day2() (r [24]bool, exists bool) {
	v := m.day_2
	if v == nil {
		return
	}
	return *v, true
}

// OldDay2 returns the old "day_2" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay2(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay2: %w", err)
	}
	return oldValue.Day2, nil
}

// ResetDay2 resets all changes to the "day_2" field.
func (m *ScheduleMutation) ResetDay2() {
	m.day_2 = nil
}

// SetDay3 sets the "day_3" field.
func (m *ScheduleMutation) SetDay3(b [24]bool) {
	m.day_3 = &b
}

// Day3 returns the value of the "day_3" field in the mutation.
func (m *ScheduleMutation) Day3() (r [24]bool, exists bool) {
	v := m.day_3
	if v == nil {
		return
	}
	return *v, true
}

// OldDay3 returns the old "day_3" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay3(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay3: %w", err)
	}
	return oldValue.Day3, nil
}

// ResetDay3 resets all changes to the "day_3" field.
func (m *ScheduleMutation) ResetDay3() {
	m.day_3 = nil
}

// SetDay4 sets the "day_4" field.
func (m *ScheduleMutation) SetDay4(b [24]bool) {
	m.day_4 = &b
}

// Day4 returns the value of the "day_4" field in the mutation.
func (m *ScheduleMutation) Day4() (r [24]bool, exists bool) {
	v := m.day_4
	if v == nil {
		return
	}
	return *v, true
}

// OldDay4 returns the old "day_4" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay4(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay4: %w", err)
	}
	return oldValue.Day4, nil
}

// ResetDay4 resets all changes to the "day_4" field.
func (m *ScheduleMutation) ResetDay4() {
	m.day_4 = nil
}

// SetDay5 sets the "day_5" field.
func (m *ScheduleMutation) SetDay5(b [24]bool) {
	m.day_5 = &b
}

// Day5 returns the value of the "day_5" field in the mutation.
func (m *ScheduleMutation) Day5() (r [24]bool, exists bool) {
	v := m.day_5
	if v == nil {
		return
	}
	return *v, true
}

// OldDay5 returns the old "day_5" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay5(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay5: %w", err)
	}
	return oldValue.Day5, nil
}

// ResetDay5 resets all changes to the "day_5" field.
func (m *ScheduleMutation) ResetDay5() {
	m.day_5 = nil
}

// SetDay6 sets the "day_6" field.
func (m *ScheduleMutation) SetDay6(b [24]bool) {
	m.day_6 = &b
}

// Day6 returns the value of the "day_6" field in the mutation.
func (m *ScheduleMutation) Day6() (r [24]bool, exists bool) {
	v := m.day_6
	if v == nil {
		return
	}
	return *v, true
}

// OldDay6 returns the old "day_6" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay6(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay6: %w", err)
	}
	return oldValue.Day6, nil
}

// ResetDay6 resets all changes to the "day_6" field.
func (m *ScheduleMutation) ResetDay6() {
	m.day_6 = nil
}

// AddTutorIDs adds the "tutor" edge to the Tutor entity by ids.
func (m *ScheduleMutation) AddTutorIDs(ids ...uuid.UUID) {
	if m.tutor == nil {
		m.tutor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tutor[ids[i]] = struct{}{}
	}
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *ScheduleMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *ScheduleMutation) TutorCleared() bool {
	return m.clearedtutor
}

// RemoveTutorIDs removes the "tutor" edge to the Tutor entity by IDs.
func (m *ScheduleMutation) RemoveTutorIDs(ids ...uuid.UUID) {
	if m.removedtutor == nil {
		m.removedtutor = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tutor, ids[i])
		m.removedtutor[ids[i]] = struct{}{}
	}
}

// RemovedTutor returns the removed IDs of the "tutor" edge to the Tutor entity.
func (m *ScheduleMutation) RemovedTutorIDs() (ids []uuid.UUID) {
	for id := range m.removedtutor {
		ids = append(ids, id)
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
func (m *ScheduleMutation) TutorIDs() (ids []uuid.UUID) {
	for id := range m.tutor {
		ids = append(ids, id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *ScheduleMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
	m.removedtutor = nil
}

// AddClasIDs adds the "class" edge to the Class entity by ids.
func (m *ScheduleMutation) AddClasIDs(ids ...uuid.UUID) {
	if m.class == nil {
		m.class = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.class[ids[i]] = struct{}{}
	}
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ScheduleMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ScheduleMutation) ClassCleared() bool {
	return m.clearedclass
}

// RemoveClasIDs removes the "class" edge to the Class entity by IDs.
func (m *ScheduleMutation) RemoveClasIDs(ids ...uuid.UUID) {
	if m.removedclass == nil {
		m.removedclass = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.class, ids[i])
		m.removedclass[ids[i]] = struct{}{}
	}
}

// RemovedClass returns the removed IDs of the "class" edge to the Class entity.
func (m *ScheduleMutation) RemovedClassIDs() (ids []uuid.UUID) {
	for id := range m.removedclass {
		ids = append(ids, id)
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
func (m *ScheduleMutation) ClassIDs() (ids []uuid.UUID) {
	for id := range m.class {
		ids = append(ids, id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ScheduleMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
	m.removedclass = nil
}

// Where appends a list predicates to the ScheduleMutation builder.
func (m *ScheduleMutation) Where(ps ...predicate.Schedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Schedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.day_0 != nil {
		fields = append(fields, schedule.FieldDay0)
	}
	if m.day_1 != nil {
		fields = append(fields, schedule.FieldDay1)
	}
	if m.day_2 != nil {
		fields = append(fields, schedule.FieldDay2)
	}
	if m.day_3 != nil {
		fields = append(fields, schedule.FieldDay3)
	}
	if m.day_4 != nil {
		fields = append(fields, schedule.FieldDay4)
	}
	if m.day_5 != nil {
		fields = append(fields, schedule.FieldDay5)
	}
	if m.day_6 != nil {
		fields = append(fields, schedule.FieldDay6)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldDay0:
		return m.Day0()
	case schedule.FieldDay1:
		return m.Day1()
	case schedule.FieldDay2:
		return m.Day2()
	case schedule.FieldDay3:
		return m.Day3()
	case schedule.FieldDay4:
		return m.Day4()
	case schedule.FieldDay5:
		return m.Day5()
	case schedule.FieldDay6:
		return m.Day6()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldDay0:
		return m.OldDay0(ctx)
	case schedule.FieldDay1:
		return m.OldDay1(ctx)
	case schedule.FieldDay2:
		return m.OldDay2(ctx)
	case schedule.FieldDay3:
		return m.OldDay3(ctx)
	case schedule.FieldDay4:
		return m.OldDay4(ctx)
	case schedule.FieldDay5:
		return m.OldDay5(ctx)
	case schedule.FieldDay6:
		return m.OldDay6(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldDay0:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay0(v)
		return nil
	case schedule.FieldDay1:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay1(v)
		return nil
	case schedule.FieldDay2:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay2(v)
		return nil
	case schedule.FieldDay3:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay3(v)
		return nil
	case schedule.FieldDay4:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay4(v)
		return nil
	case schedule.FieldDay5:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay5(v)
		return nil
	case schedule.FieldDay6:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay6(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldDay0:
		m.ResetDay0()
		return nil
	case schedule.FieldDay1:
		m.ResetDay1()
		return nil
	case schedule.FieldDay2:
		m.ResetDay2()
		return nil
	case schedule.FieldDay3:
		m.ResetDay3()
		return nil
	case schedule.FieldDay4:
		m.ResetDay4()
		return nil
	case schedule.FieldDay5:
		m.ResetDay5()
		return nil
	case schedule.FieldDay6:
		m.ResetDay6()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tutor != nil {
		edges = append(edges, schedule.EdgeTutor)
	}
	if m.class != nil {
		edges = append(edges, schedule.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeTutor:
		ids := make([]ent.Value, 0, len(m.tutor))
		for id := range m.tutor {
			ids = append(ids, id)
		}
		return ids
	case schedule.EdgeClass:
		ids := make([]ent.Value, 0, len(m.class))
		for id := range m.class {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtutor != nil {
		edges = append(edges, schedule.EdgeTutor)
	}
	if m.removedclass != nil {
		edges = append(edges, schedule.EdgeClass)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeTutor:
		ids := make([]ent.Value, 0, len(m.removedtutor))
		for id := range m.removedtutor {
			ids = append(ids, id)
		}
		return ids
	case schedule.EdgeClass:
		ids := make([]ent.Value, 0, len(m.removedclass))
		for id := range m.removedclass {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtutor {
		edges = append(edges, schedule.EdgeTutor)
	}
	if m.clearedclass {
		edges = append(edges, schedule.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case schedule.EdgeTutor:
		return m.clearedtutor
	case schedule.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	switch name {
	case schedule.EdgeTutor:
		m.ResetTutor()
		return nil
	case schedule.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	clearedFields        map[string]struct{}
	match                map[uuid.UUID]struct{}
	removedmatch         map[uuid.UUID]struct{}
	clearedmatch         bool
	review_course        map[int]struct{}
	removedreview_course map[int]struct{}
	clearedreview_course bool
	review_tutor         map[int]struct{}
	removedreview_tutor  map[int]struct{}
	clearedreview_tutor  bool
	user                 *uuid.UUID
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Student, error)
	predicates           []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id uuid.UUID) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Student.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddMatchIDs adds the "match" edge to the Match entity by ids.
func (m *StudentMutation) AddMatchIDs(ids ...uuid.UUID) {
	if m.match == nil {
		m.match = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.match[ids[i]] = struct{}{}
	}
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *StudentMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *StudentMutation) MatchCleared() bool {
	return m.clearedmatch
}

// RemoveMatchIDs removes the "match" edge to the Match entity by IDs.
func (m *StudentMutation) RemoveMatchIDs(ids ...uuid.UUID) {
	if m.removedmatch == nil {
		m.removedmatch = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.match, ids[i])
		m.removedmatch[ids[i]] = struct{}{}
	}
}

// RemovedMatch returns the removed IDs of the "match" edge to the Match entity.
func (m *StudentMutation) RemovedMatchIDs() (ids []uuid.UUID) {
	for id := range m.removedmatch {
		ids = append(ids, id)
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
func (m *StudentMutation) MatchIDs() (ids []uuid.UUID) {
	for id := range m.match {
		ids = append(ids, id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *StudentMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
	m.removedmatch = nil
}

// AddReviewCourseIDs adds the "review_course" edge to the ReviewCourse entity by ids.
func (m *StudentMutation) AddReviewCourseIDs(ids ...int) {
	if m.review_course == nil {
		m.review_course = make(map[int]struct{})
	}
	for i := range ids {
		m.review_course[ids[i]] = struct{}{}
	}
}

// ClearReviewCourse clears the "review_course" edge to the ReviewCourse entity.
func (m *StudentMutation) ClearReviewCourse() {
	m.clearedreview_course = true
}

// ReviewCourseCleared reports if the "review_course" edge to the ReviewCourse entity was cleared.
func (m *StudentMutation) ReviewCourseCleared() bool {
	return m.clearedreview_course
}

// RemoveReviewCourseIDs removes the "review_course" edge to the ReviewCourse entity by IDs.
func (m *StudentMutation) RemoveReviewCourseIDs(ids ...int) {
	if m.removedreview_course == nil {
		m.removedreview_course = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.review_course, ids[i])
		m.removedreview_course[ids[i]] = struct{}{}
	}
}

// RemovedReviewCourse returns the removed IDs of the "review_course" edge to the ReviewCourse entity.
func (m *StudentMutation) RemovedReviewCourseIDs() (ids []int) {
	for id := range m.removedreview_course {
		ids = append(ids, id)
	}
	return
}

// ReviewCourseIDs returns the "review_course" edge IDs in the mutation.
func (m *StudentMutation) ReviewCourseIDs() (ids []int) {
	for id := range m.review_course {
		ids = append(ids, id)
	}
	return
}

// ResetReviewCourse resets all changes to the "review_course" edge.
func (m *StudentMutation) ResetReviewCourse() {
	m.review_course = nil
	m.clearedreview_course = false
	m.removedreview_course = nil
}

// AddReviewTutorIDs adds the "review_tutor" edge to the ReviewTutor entity by ids.
func (m *StudentMutation) AddReviewTutorIDs(ids ...int) {
	if m.review_tutor == nil {
		m.review_tutor = make(map[int]struct{})
	}
	for i := range ids {
		m.review_tutor[ids[i]] = struct{}{}
	}
}

// ClearReviewTutor clears the "review_tutor" edge to the ReviewTutor entity.
func (m *StudentMutation) ClearReviewTutor() {
	m.clearedreview_tutor = true
}

// ReviewTutorCleared reports if the "review_tutor" edge to the ReviewTutor entity was cleared.
func (m *StudentMutation) ReviewTutorCleared() bool {
	return m.clearedreview_tutor
}

// RemoveReviewTutorIDs removes the "review_tutor" edge to the ReviewTutor entity by IDs.
func (m *StudentMutation) RemoveReviewTutorIDs(ids ...int) {
	if m.removedreview_tutor == nil {
		m.removedreview_tutor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.review_tutor, ids[i])
		m.removedreview_tutor[ids[i]] = struct{}{}
	}
}

// RemovedReviewTutor returns the removed IDs of the "review_tutor" edge to the ReviewTutor entity.
func (m *StudentMutation) RemovedReviewTutorIDs() (ids []int) {
	for id := range m.removedreview_tutor {
		ids = append(ids, id)
	}
	return
}

// ReviewTutorIDs returns the "review_tutor" edge IDs in the mutation.
func (m *StudentMutation) ReviewTutorIDs() (ids []int) {
	for id := range m.review_tutor {
		ids = append(ids, id)
	}
	return
}

// ResetReviewTutor resets all changes to the "review_tutor" edge.
func (m *StudentMutation) ResetReviewTutor() {
	m.review_tutor = nil
	m.clearedreview_tutor = false
	m.removedreview_tutor = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StudentMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StudentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StudentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StudentMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StudentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StudentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StudentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Student, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StudentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.match != nil {
		edges = append(edges, student.EdgeMatch)
	}
	if m.review_course != nil {
		edges = append(edges, student.EdgeReviewCourse)
	}
	if m.review_tutor != nil {
		edges = append(edges, student.EdgeReviewTutor)
	}
	if m.user != nil {
		edges = append(edges, student.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.match))
		for id := range m.match {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeReviewCourse:
		ids := make([]ent.Value, 0, len(m.review_course))
		for id := range m.review_course {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeReviewTutor:
		ids := make([]ent.Value, 0, len(m.review_tutor))
		for id := range m.review_tutor {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmatch != nil {
		edges = append(edges, student.EdgeMatch)
	}
	if m.removedreview_course != nil {
		edges = append(edges, student.EdgeReviewCourse)
	}
	if m.removedreview_tutor != nil {
		edges = append(edges, student.EdgeReviewTutor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.removedmatch))
		for id := range m.removedmatch {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeReviewCourse:
		ids := make([]ent.Value, 0, len(m.removedreview_course))
		for id := range m.removedreview_course {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeReviewTutor:
		ids := make([]ent.Value, 0, len(m.removedreview_tutor))
		for id := range m.removedreview_tutor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmatch {
		edges = append(edges, student.EdgeMatch)
	}
	if m.clearedreview_course {
		edges = append(edges, student.EdgeReviewCourse)
	}
	if m.clearedreview_tutor {
		edges = append(edges, student.EdgeReviewTutor)
	}
	if m.cleareduser {
		edges = append(edges, student.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeMatch:
		return m.clearedmatch
	case student.EdgeReviewCourse:
		return m.clearedreview_course
	case student.EdgeReviewTutor:
		return m.clearedreview_tutor
	case student.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeMatch:
		m.ResetMatch()
		return nil
	case student.EdgeReviewCourse:
		m.ResetReviewCourse()
		return nil
	case student.EdgeReviewTutor:
		m.ResetReviewTutor()
		return nil
	case student.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// TutorMutation represents an operation that mutates the Tutor nodes in the graph.
type TutorMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	description         *string
	omise_bank_token    *string
	citizen_id          *string
	clearedFields       map[string]struct{}
	issue_report        map[uuid.UUID]struct{}
	removedissue_report map[uuid.UUID]struct{}
	clearedissue_report bool
	course              map[uuid.UUID]struct{}
	removedcourse       map[uuid.UUID]struct{}
	clearedcourse       bool
	review_tutor        map[int]struct{}
	removedreview_tutor map[int]struct{}
	clearedreview_tutor bool
	user                *uuid.UUID
	cleareduser         bool
	schedule            *uuid.UUID
	clearedschedule     bool
	done                bool
	oldValue            func(context.Context) (*Tutor, error)
	predicates          []predicate.Tutor
}

var _ ent.Mutation = (*TutorMutation)(nil)

// tutorOption allows management of the mutation configuration using functional options.
type tutorOption func(*TutorMutation)

// newTutorMutation creates new mutation for the Tutor entity.
func newTutorMutation(c config, op Op, opts ...tutorOption) *TutorMutation {
	m := &TutorMutation{
		config:        c,
		op:            op,
		typ:           TypeTutor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTutorID sets the ID field of the mutation.
func withTutorID(id uuid.UUID) tutorOption {
	return func(m *TutorMutation) {
		var (
			err   error
			once  sync.Once
			value *Tutor
		)
		m.oldValue = func(ctx context.Context) (*Tutor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tutor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTutor sets the old Tutor of the mutation.
func withTutor(node *Tutor) tutorOption {
	return func(m *TutorMutation) {
		m.oldValue = func(context.Context) (*Tutor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TutorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TutorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tutor entities.
func (m *TutorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TutorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TutorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tutor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *TutorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TutorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TutorMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tutor.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TutorMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tutor.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TutorMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tutor.FieldDescription)
}

// SetOmiseBankToken sets the "omise_bank_token" field.
func (m *TutorMutation) SetOmiseBankToken(s string) {
	m.omise_bank_token = &s
}

// OmiseBankToken returns the value of the "omise_bank_token" field in the mutation.
func (m *TutorMutation) OmiseBankToken() (r string, exists bool) {
	v := m.omise_bank_token
	if v == nil {
		return
	}
	return *v, true
}

// OldOmiseBankToken returns the old "omise_bank_token" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldOmiseBankToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOmiseBankToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOmiseBankToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOmiseBankToken: %w", err)
	}
	return oldValue.OmiseBankToken, nil
}

// ClearOmiseBankToken clears the value of the "omise_bank_token" field.
func (m *TutorMutation) ClearOmiseBankToken() {
	m.omise_bank_token = nil
	m.clearedFields[tutor.FieldOmiseBankToken] = struct{}{}
}

// OmiseBankTokenCleared returns if the "omise_bank_token" field was cleared in this mutation.
func (m *TutorMutation) OmiseBankTokenCleared() bool {
	_, ok := m.clearedFields[tutor.FieldOmiseBankToken]
	return ok
}

// ResetOmiseBankToken resets all changes to the "omise_bank_token" field.
func (m *TutorMutation) ResetOmiseBankToken() {
	m.omise_bank_token = nil
	delete(m.clearedFields, tutor.FieldOmiseBankToken)
}

// SetCitizenID sets the "citizen_id" field.
func (m *TutorMutation) SetCitizenID(s string) {
	m.citizen_id = &s
}

// CitizenID returns the value of the "citizen_id" field in the mutation.
func (m *TutorMutation) CitizenID() (r string, exists bool) {
	v := m.citizen_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCitizenID returns the old "citizen_id" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldCitizenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCitizenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCitizenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitizenID: %w", err)
	}
	return oldValue.CitizenID, nil
}

// ResetCitizenID resets all changes to the "citizen_id" field.
func (m *TutorMutation) ResetCitizenID() {
	m.citizen_id = nil
}

// AddIssueReportIDs adds the "issue_report" edge to the IssueReport entity by ids.
func (m *TutorMutation) AddIssueReportIDs(ids ...uuid.UUID) {
	if m.issue_report == nil {
		m.issue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.issue_report[ids[i]] = struct{}{}
	}
}

// ClearIssueReport clears the "issue_report" edge to the IssueReport entity.
func (m *TutorMutation) ClearIssueReport() {
	m.clearedissue_report = true
}

// IssueReportCleared reports if the "issue_report" edge to the IssueReport entity was cleared.
func (m *TutorMutation) IssueReportCleared() bool {
	return m.clearedissue_report
}

// RemoveIssueReportIDs removes the "issue_report" edge to the IssueReport entity by IDs.
func (m *TutorMutation) RemoveIssueReportIDs(ids ...uuid.UUID) {
	if m.removedissue_report == nil {
		m.removedissue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.issue_report, ids[i])
		m.removedissue_report[ids[i]] = struct{}{}
	}
}

// RemovedIssueReport returns the removed IDs of the "issue_report" edge to the IssueReport entity.
func (m *TutorMutation) RemovedIssueReportIDs() (ids []uuid.UUID) {
	for id := range m.removedissue_report {
		ids = append(ids, id)
	}
	return
}

// IssueReportIDs returns the "issue_report" edge IDs in the mutation.
func (m *TutorMutation) IssueReportIDs() (ids []uuid.UUID) {
	for id := range m.issue_report {
		ids = append(ids, id)
	}
	return
}

// ResetIssueReport resets all changes to the "issue_report" edge.
func (m *TutorMutation) ResetIssueReport() {
	m.issue_report = nil
	m.clearedissue_report = false
	m.removedissue_report = nil
}

// AddCourseIDs adds the "course" edge to the Course entity by ids.
func (m *TutorMutation) AddCourseIDs(ids ...uuid.UUID) {
	if m.course == nil {
		m.course = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *TutorMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *TutorMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the Course entity by IDs.
func (m *TutorMutation) RemoveCourseIDs(ids ...uuid.UUID) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course, ids[i])
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the Course entity.
func (m *TutorMutation) RemovedCourseIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *TutorMutation) CourseIDs() (ids []uuid.UUID) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *TutorMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// AddReviewTutorIDs adds the "review_tutor" edge to the ReviewTutor entity by ids.
func (m *TutorMutation) AddReviewTutorIDs(ids ...int) {
	if m.review_tutor == nil {
		m.review_tutor = make(map[int]struct{})
	}
	for i := range ids {
		m.review_tutor[ids[i]] = struct{}{}
	}
}

// ClearReviewTutor clears the "review_tutor" edge to the ReviewTutor entity.
func (m *TutorMutation) ClearReviewTutor() {
	m.clearedreview_tutor = true
}

// ReviewTutorCleared reports if the "review_tutor" edge to the ReviewTutor entity was cleared.
func (m *TutorMutation) ReviewTutorCleared() bool {
	return m.clearedreview_tutor
}

// RemoveReviewTutorIDs removes the "review_tutor" edge to the ReviewTutor entity by IDs.
func (m *TutorMutation) RemoveReviewTutorIDs(ids ...int) {
	if m.removedreview_tutor == nil {
		m.removedreview_tutor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.review_tutor, ids[i])
		m.removedreview_tutor[ids[i]] = struct{}{}
	}
}

// RemovedReviewTutor returns the removed IDs of the "review_tutor" edge to the ReviewTutor entity.
func (m *TutorMutation) RemovedReviewTutorIDs() (ids []int) {
	for id := range m.removedreview_tutor {
		ids = append(ids, id)
	}
	return
}

// ReviewTutorIDs returns the "review_tutor" edge IDs in the mutation.
func (m *TutorMutation) ReviewTutorIDs() (ids []int) {
	for id := range m.review_tutor {
		ids = append(ids, id)
	}
	return
}

// ResetReviewTutor resets all changes to the "review_tutor" edge.
func (m *TutorMutation) ResetReviewTutor() {
	m.review_tutor = nil
	m.clearedreview_tutor = false
	m.removedreview_tutor = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TutorMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TutorMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TutorMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TutorMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TutorMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TutorMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetScheduleID sets the "schedule" edge to the Schedule entity by id.
func (m *TutorMutation) SetScheduleID(id uuid.UUID) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *TutorMutation) ClearSchedule() {
	m.clearedschedule = true
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *TutorMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *TutorMutation) ScheduleID() (id uuid.UUID, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *TutorMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *TutorMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// Where appends a list predicates to the TutorMutation builder.
func (m *TutorMutation) Where(ps ...predicate.Tutor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TutorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TutorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tutor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TutorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TutorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tutor).
func (m *TutorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TutorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.description != nil {
		fields = append(fields, tutor.FieldDescription)
	}
	if m.omise_bank_token != nil {
		fields = append(fields, tutor.FieldOmiseBankToken)
	}
	if m.citizen_id != nil {
		fields = append(fields, tutor.FieldCitizenID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TutorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tutor.FieldDescription:
		return m.Description()
	case tutor.FieldOmiseBankToken:
		return m.OmiseBankToken()
	case tutor.FieldCitizenID:
		return m.CitizenID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TutorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tutor.FieldDescription:
		return m.OldDescription(ctx)
	case tutor.FieldOmiseBankToken:
		return m.OldOmiseBankToken(ctx)
	case tutor.FieldCitizenID:
		return m.OldCitizenID(ctx)
	}
	return nil, fmt.Errorf("unknown Tutor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TutorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tutor.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tutor.FieldOmiseBankToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOmiseBankToken(v)
		return nil
	case tutor.FieldCitizenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitizenID(v)
		return nil
	}
	return fmt.Errorf("unknown Tutor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TutorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TutorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TutorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tutor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TutorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tutor.FieldDescription) {
		fields = append(fields, tutor.FieldDescription)
	}
	if m.FieldCleared(tutor.FieldOmiseBankToken) {
		fields = append(fields, tutor.FieldOmiseBankToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TutorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TutorMutation) ClearField(name string) error {
	switch name {
	case tutor.FieldDescription:
		m.ClearDescription()
		return nil
	case tutor.FieldOmiseBankToken:
		m.ClearOmiseBankToken()
		return nil
	}
	return fmt.Errorf("unknown Tutor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TutorMutation) ResetField(name string) error {
	switch name {
	case tutor.FieldDescription:
		m.ResetDescription()
		return nil
	case tutor.FieldOmiseBankToken:
		m.ResetOmiseBankToken()
		return nil
	case tutor.FieldCitizenID:
		m.ResetCitizenID()
		return nil
	}
	return fmt.Errorf("unknown Tutor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TutorMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.issue_report != nil {
		edges = append(edges, tutor.EdgeIssueReport)
	}
	if m.course != nil {
		edges = append(edges, tutor.EdgeCourse)
	}
	if m.review_tutor != nil {
		edges = append(edges, tutor.EdgeReviewTutor)
	}
	if m.user != nil {
		edges = append(edges, tutor.EdgeUser)
	}
	if m.schedule != nil {
		edges = append(edges, tutor.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TutorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tutor.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.issue_report))
		for id := range m.issue_report {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeReviewTutor:
		ids := make([]ent.Value, 0, len(m.review_tutor))
		for id := range m.review_tutor {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case tutor.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TutorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedissue_report != nil {
		edges = append(edges, tutor.EdgeIssueReport)
	}
	if m.removedcourse != nil {
		edges = append(edges, tutor.EdgeCourse)
	}
	if m.removedreview_tutor != nil {
		edges = append(edges, tutor.EdgeReviewTutor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TutorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tutor.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.removedissue_report))
		for id := range m.removedissue_report {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeReviewTutor:
		ids := make([]ent.Value, 0, len(m.removedreview_tutor))
		for id := range m.removedreview_tutor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TutorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedissue_report {
		edges = append(edges, tutor.EdgeIssueReport)
	}
	if m.clearedcourse {
		edges = append(edges, tutor.EdgeCourse)
	}
	if m.clearedreview_tutor {
		edges = append(edges, tutor.EdgeReviewTutor)
	}
	if m.cleareduser {
		edges = append(edges, tutor.EdgeUser)
	}
	if m.clearedschedule {
		edges = append(edges, tutor.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TutorMutation) EdgeCleared(name string) bool {
	switch name {
	case tutor.EdgeIssueReport:
		return m.clearedissue_report
	case tutor.EdgeCourse:
		return m.clearedcourse
	case tutor.EdgeReviewTutor:
		return m.clearedreview_tutor
	case tutor.EdgeUser:
		return m.cleareduser
	case tutor.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TutorMutation) ClearEdge(name string) error {
	switch name {
	case tutor.EdgeUser:
		m.ClearUser()
		return nil
	case tutor.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown Tutor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TutorMutation) ResetEdge(name string) error {
	switch name {
	case tutor.EdgeIssueReport:
		m.ResetIssueReport()
		return nil
	case tutor.EdgeCourse:
		m.ResetCourse()
		return nil
	case tutor.EdgeReviewTutor:
		m.ResetReviewTutor()
		return nil
	case tutor.EdgeUser:
		m.ResetUser()
		return nil
	case tutor.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown Tutor edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	username               *string
	password               *string
	email                  *string
	first_name             *string
	last_name              *string
	address                *string
	phone                  *string
	birth_date             *time.Time
	gender                 *string
	profile_picture_URL    *string
	role                   *user.Role
	clearedFields          map[string]struct{}
	student                *uuid.UUID
	clearedstudent         bool
	tutor                  *uuid.UUID
	clearedtutor           bool
	payment                map[uuid.UUID]struct{}
	removedpayment         map[uuid.UUID]struct{}
	clearedpayment         bool
	payment_history        map[uuid.UUID]struct{}
	removedpayment_history map[uuid.UUID]struct{}
	clearedpayment_history bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetBirthDate sets the "birth_date" field.
func (m *UserMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *UserMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *UserMutation) ResetBirthDate() {
	m.birth_date = nil
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
}

// SetProfilePictureURL sets the "profile_picture_URL" field.
func (m *UserMutation) SetProfilePictureURL(s string) {
	m.profile_picture_URL = &s
}

// ProfilePictureURL returns the value of the "profile_picture_URL" field in the mutation.
func (m *UserMutation) ProfilePictureURL() (r string, exists bool) {
	v := m.profile_picture_URL
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureURL returns the old "profile_picture_URL" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfilePictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureURL: %w", err)
	}
	return oldValue.ProfilePictureURL, nil
}

// ClearProfilePictureURL clears the value of the "profile_picture_URL" field.
func (m *UserMutation) ClearProfilePictureURL() {
	m.profile_picture_URL = nil
	m.clearedFields[user.FieldProfilePictureURL] = struct{}{}
}

// ProfilePictureURLCleared returns if the "profile_picture_URL" field was cleared in this mutation.
func (m *UserMutation) ProfilePictureURLCleared() bool {
	_, ok := m.clearedFields[user.FieldProfilePictureURL]
	return ok
}

// ResetProfilePictureURL resets all changes to the "profile_picture_URL" field.
func (m *UserMutation) ResetProfilePictureURL() {
	m.profile_picture_URL = nil
	delete(m.clearedFields, user.FieldProfilePictureURL)
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v *user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *UserMutation) SetStudentID(id uuid.UUID) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *UserMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *UserMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *UserMutation) StudentID() (id uuid.UUID, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) StudentIDs() (ids []uuid.UUID) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *UserMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *UserMutation) SetTutorID(id uuid.UUID) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *UserMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *UserMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *UserMutation) TutorID() (id uuid.UUID, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TutorIDs() (ids []uuid.UUID) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *UserMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// AddPaymentIDs adds the "payment" edge to the Payment entity by ids.
func (m *UserMutation) AddPaymentIDs(ids ...uuid.UUID) {
	if m.payment == nil {
		m.payment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *UserMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *UserMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// RemovePaymentIDs removes the "payment" edge to the Payment entity by IDs.
func (m *UserMutation) RemovePaymentIDs(ids ...uuid.UUID) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.payment, ids[i])
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed IDs of the "payment" edge to the Payment entity.
func (m *UserMutation) RemovedPaymentIDs() (ids []uuid.UUID) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
func (m *UserMutation) PaymentIDs() (ids []uuid.UUID) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *UserMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
	m.removedpayment = nil
}

// AddPaymentHistoryIDs adds the "payment_history" edge to the PaymentHistory entity by ids.
func (m *UserMutation) AddPaymentHistoryIDs(ids ...uuid.UUID) {
	if m.payment_history == nil {
		m.payment_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.payment_history[ids[i]] = struct{}{}
	}
}

// ClearPaymentHistory clears the "payment_history" edge to the PaymentHistory entity.
func (m *UserMutation) ClearPaymentHistory() {
	m.clearedpayment_history = true
}

// PaymentHistoryCleared reports if the "payment_history" edge to the PaymentHistory entity was cleared.
func (m *UserMutation) PaymentHistoryCleared() bool {
	return m.clearedpayment_history
}

// RemovePaymentHistoryIDs removes the "payment_history" edge to the PaymentHistory entity by IDs.
func (m *UserMutation) RemovePaymentHistoryIDs(ids ...uuid.UUID) {
	if m.removedpayment_history == nil {
		m.removedpayment_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.payment_history, ids[i])
		m.removedpayment_history[ids[i]] = struct{}{}
	}
}

// RemovedPaymentHistory returns the removed IDs of the "payment_history" edge to the PaymentHistory entity.
func (m *UserMutation) RemovedPaymentHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedpayment_history {
		ids = append(ids, id)
	}
	return
}

// PaymentHistoryIDs returns the "payment_history" edge IDs in the mutation.
func (m *UserMutation) PaymentHistoryIDs() (ids []uuid.UUID) {
	for id := range m.payment_history {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentHistory resets all changes to the "payment_history" edge.
func (m *UserMutation) ResetPaymentHistory() {
	m.payment_history = nil
	m.clearedpayment_history = false
	m.removedpayment_history = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.birth_date != nil {
		fields = append(fields, user.FieldBirthDate)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.profile_picture_URL != nil {
		fields = append(fields, user.FieldProfilePictureURL)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAddress:
		return m.Address()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldBirthDate:
		return m.BirthDate()
	case user.FieldGender:
		return m.Gender()
	case user.FieldProfilePictureURL:
		return m.ProfilePictureURL()
	case user.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldProfilePictureURL:
		return m.OldProfilePictureURL(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case user.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldProfilePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureURL(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldProfilePictureURL) {
		fields = append(fields, user.FieldProfilePictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldProfilePictureURL:
		m.ClearProfilePictureURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldProfilePictureURL:
		m.ResetProfilePictureURL()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.student != nil {
		edges = append(edges, user.EdgeStudent)
	}
	if m.tutor != nil {
		edges = append(edges, user.EdgeTutor)
	}
	if m.payment != nil {
		edges = append(edges, user.EdgePayment)
	}
	if m.payment_history != nil {
		edges = append(edges, user.EdgePaymentHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePaymentHistory:
		ids := make([]ent.Value, 0, len(m.payment_history))
		for id := range m.payment_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpayment != nil {
		edges = append(edges, user.EdgePayment)
	}
	if m.removedpayment_history != nil {
		edges = append(edges, user.EdgePaymentHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePaymentHistory:
		ids := make([]ent.Value, 0, len(m.removedpayment_history))
		for id := range m.removedpayment_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedstudent {
		edges = append(edges, user.EdgeStudent)
	}
	if m.clearedtutor {
		edges = append(edges, user.EdgeTutor)
	}
	if m.clearedpayment {
		edges = append(edges, user.EdgePayment)
	}
	if m.clearedpayment_history {
		edges = append(edges, user.EdgePaymentHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeStudent:
		return m.clearedstudent
	case user.EdgeTutor:
		return m.clearedtutor
	case user.EdgePayment:
		return m.clearedpayment
	case user.EdgePaymentHistory:
		return m.clearedpayment_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeStudent:
		m.ClearStudent()
		return nil
	case user.EdgeTutor:
		m.ClearTutor()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeStudent:
		m.ResetStudent()
		return nil
	case user.EdgeTutor:
		m.ResetTutor()
		return nil
	case user.EdgePayment:
		m.ResetPayment()
		return nil
	case user.EdgePaymentHistory:
		m.ResetPaymentHistory()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
