// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/class"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/course"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/issuereport"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/payment"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/paymenthistory"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/predicate"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/reviewcourse"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/reviewtutor"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/schedule"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/student"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/tutor"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/user"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClass          = "Class"
	TypeCourse         = "Course"
	TypeIssueReport    = "IssueReport"
	TypePayment        = "Payment"
	TypePaymentHistory = "PaymentHistory"
	TypeReviewCourse   = "ReviewCourse"
	TypeReviewTutor    = "ReviewTutor"
	TypeSchedule       = "Schedule"
	TypeStudent        = "Student"
	TypeTutor          = "Tutor"
	TypeUser           = "User"
)

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	review_avaliable *bool
	total_hour       *time.Time
	success_hour     *time.Time
	clearedFields    map[string]struct{}
	schedule         *uuid.UUID
	clearedschedule  bool
	student          *uuid.UUID
	clearedstudent   bool
	course           *uuid.UUID
	clearedcourse    bool
	done             bool
	oldValue         func(context.Context) (*Class, error)
	predicates       []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id uuid.UUID) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Class entities.
func (m *ClassMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Class.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReviewAvaliable sets the "review_avaliable" field.
func (m *ClassMutation) SetReviewAvaliable(b bool) {
	m.review_avaliable = &b
}

// ReviewAvaliable returns the value of the "review_avaliable" field in the mutation.
func (m *ClassMutation) ReviewAvaliable() (r bool, exists bool) {
	v := m.review_avaliable
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewAvaliable returns the old "review_avaliable" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldReviewAvaliable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewAvaliable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewAvaliable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewAvaliable: %w", err)
	}
	return oldValue.ReviewAvaliable, nil
}

// ResetReviewAvaliable resets all changes to the "review_avaliable" field.
func (m *ClassMutation) ResetReviewAvaliable() {
	m.review_avaliable = nil
}

// SetTotalHour sets the "total_hour" field.
func (m *ClassMutation) SetTotalHour(t time.Time) {
	m.total_hour = &t
}

// TotalHour returns the value of the "total_hour" field in the mutation.
func (m *ClassMutation) TotalHour() (r time.Time, exists bool) {
	v := m.total_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalHour returns the old "total_hour" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldTotalHour(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalHour: %w", err)
	}
	return oldValue.TotalHour, nil
}

// ResetTotalHour resets all changes to the "total_hour" field.
func (m *ClassMutation) ResetTotalHour() {
	m.total_hour = nil
}

// SetSuccessHour sets the "success_hour" field.
func (m *ClassMutation) SetSuccessHour(t time.Time) {
	m.success_hour = &t
}

// SuccessHour returns the value of the "success_hour" field in the mutation.
func (m *ClassMutation) SuccessHour() (r time.Time, exists bool) {
	v := m.success_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessHour returns the old "success_hour" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldSuccessHour(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessHour: %w", err)
	}
	return oldValue.SuccessHour, nil
}

// ResetSuccessHour resets all changes to the "success_hour" field.
func (m *ClassMutation) ResetSuccessHour() {
	m.success_hour = nil
}

// SetScheduleID sets the "schedule" edge to the Schedule entity by id.
func (m *ClassMutation) SetScheduleID(id uuid.UUID) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *ClassMutation) ClearSchedule() {
	m.clearedschedule = true
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *ClassMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *ClassMutation) ScheduleID() (id uuid.UUID, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *ClassMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *ClassMutation) SetStudentID(id uuid.UUID) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *ClassMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *ClassMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *ClassMutation) StudentID() (id uuid.UUID, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) StudentIDs() (ids []uuid.UUID) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ClassMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetCourseID sets the "course" edge to the Course entity by id.
func (m *ClassMutation) SetCourseID(id uuid.UUID) {
	m.course = &id
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *ClassMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *ClassMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the "course" edge ID in the mutation.
func (m *ClassMutation) CourseID() (id uuid.UUID, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ClassMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Class, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.review_avaliable != nil {
		fields = append(fields, class.FieldReviewAvaliable)
	}
	if m.total_hour != nil {
		fields = append(fields, class.FieldTotalHour)
	}
	if m.success_hour != nil {
		fields = append(fields, class.FieldSuccessHour)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldReviewAvaliable:
		return m.ReviewAvaliable()
	case class.FieldTotalHour:
		return m.TotalHour()
	case class.FieldSuccessHour:
		return m.SuccessHour()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldReviewAvaliable:
		return m.OldReviewAvaliable(ctx)
	case class.FieldTotalHour:
		return m.OldTotalHour(ctx)
	case class.FieldSuccessHour:
		return m.OldSuccessHour(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldReviewAvaliable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewAvaliable(v)
		return nil
	case class.FieldTotalHour:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalHour(v)
		return nil
	case class.FieldSuccessHour:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessHour(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldReviewAvaliable:
		m.ResetReviewAvaliable()
		return nil
	case class.FieldTotalHour:
		m.ResetTotalHour()
		return nil
	case class.FieldSuccessHour:
		m.ResetSuccessHour()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.schedule != nil {
		edges = append(edges, class.EdgeSchedule)
	}
	if m.student != nil {
		edges = append(edges, class.EdgeStudent)
	}
	if m.course != nil {
		edges = append(edges, class.EdgeCourse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedschedule {
		edges = append(edges, class.EdgeSchedule)
	}
	if m.clearedstudent {
		edges = append(edges, class.EdgeStudent)
	}
	if m.clearedcourse {
		edges = append(edges, class.EdgeCourse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeSchedule:
		return m.clearedschedule
	case class.EdgeStudent:
		return m.clearedstudent
	case class.EdgeCourse:
		return m.clearedcourse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	case class.EdgeSchedule:
		m.ClearSchedule()
		return nil
	case class.EdgeStudent:
		m.ClearStudent()
		return nil
	case class.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeSchedule:
		m.ResetSchedule()
		return nil
	case class.EdgeStudent:
		m.ResetStudent()
		return nil
	case class.EdgeCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	title                *string
	estimated_time       *time.Time
	description          *string
	course_status        *string
	price_per_hour       *int
	addprice_per_hour    *int
	level_id             *string
	course_picture_url   *string
	clearedFields        map[string]struct{}
	review_course        map[int]struct{}
	removedreview_course map[int]struct{}
	clearedreview_course bool
	class                *uuid.UUID
	clearedclass         bool
	student              *uuid.UUID
	clearedstudent       bool
	tutor                *uuid.UUID
	clearedtutor         bool
	done                 bool
	oldValue             func(context.Context) (*Course, error)
	predicates           []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id uuid.UUID) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Course entities.
func (m *CourseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *CourseMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseMutation) ResetTitle() {
	m.title = nil
}

// SetEstimatedTime sets the "estimated_time" field.
func (m *CourseMutation) SetEstimatedTime(t time.Time) {
	m.estimated_time = &t
}

// EstimatedTime returns the value of the "estimated_time" field in the mutation.
func (m *CourseMutation) EstimatedTime() (r time.Time, exists bool) {
	v := m.estimated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedTime returns the old "estimated_time" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldEstimatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedTime: %w", err)
	}
	return oldValue.EstimatedTime, nil
}

// ResetEstimatedTime resets all changes to the "estimated_time" field.
func (m *CourseMutation) ResetEstimatedTime() {
	m.estimated_time = nil
}

// SetDescription sets the "description" field.
func (m *CourseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CourseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CourseMutation) ResetDescription() {
	m.description = nil
}

// SetCourseStatus sets the "course_status" field.
func (m *CourseMutation) SetCourseStatus(s string) {
	m.course_status = &s
}

// CourseStatus returns the value of the "course_status" field in the mutation.
func (m *CourseMutation) CourseStatus() (r string, exists bool) {
	v := m.course_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseStatus returns the old "course_status" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCourseStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseStatus: %w", err)
	}
	return oldValue.CourseStatus, nil
}

// ResetCourseStatus resets all changes to the "course_status" field.
func (m *CourseMutation) ResetCourseStatus() {
	m.course_status = nil
}

// SetPricePerHour sets the "price_per_hour" field.
func (m *CourseMutation) SetPricePerHour(i int) {
	m.price_per_hour = &i
	m.addprice_per_hour = nil
}

// PricePerHour returns the value of the "price_per_hour" field in the mutation.
func (m *CourseMutation) PricePerHour() (r int, exists bool) {
	v := m.price_per_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePerHour returns the old "price_per_hour" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldPricePerHour(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePerHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePerHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePerHour: %w", err)
	}
	return oldValue.PricePerHour, nil
}

// AddPricePerHour adds i to the "price_per_hour" field.
func (m *CourseMutation) AddPricePerHour(i int) {
	if m.addprice_per_hour != nil {
		*m.addprice_per_hour += i
	} else {
		m.addprice_per_hour = &i
	}
}

// AddedPricePerHour returns the value that was added to the "price_per_hour" field in this mutation.
func (m *CourseMutation) AddedPricePerHour() (r int, exists bool) {
	v := m.addprice_per_hour
	if v == nil {
		return
	}
	return *v, true
}

// ResetPricePerHour resets all changes to the "price_per_hour" field.
func (m *CourseMutation) ResetPricePerHour() {
	m.price_per_hour = nil
	m.addprice_per_hour = nil
}

// SetLevelID sets the "level_id" field.
func (m *CourseMutation) SetLevelID(s string) {
	m.level_id = &s
}

// LevelID returns the value of the "level_id" field in the mutation.
func (m *CourseMutation) LevelID() (r string, exists bool) {
	v := m.level_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelID returns the old "level_id" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldLevelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelID: %w", err)
	}
	return oldValue.LevelID, nil
}

// ResetLevelID resets all changes to the "level_id" field.
func (m *CourseMutation) ResetLevelID() {
	m.level_id = nil
}

// SetCoursePictureURL sets the "course_picture_url" field.
func (m *CourseMutation) SetCoursePictureURL(s string) {
	m.course_picture_url = &s
}

// CoursePictureURL returns the value of the "course_picture_url" field in the mutation.
func (m *CourseMutation) CoursePictureURL() (r string, exists bool) {
	v := m.course_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoursePictureURL returns the old "course_picture_url" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCoursePictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoursePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoursePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoursePictureURL: %w", err)
	}
	return oldValue.CoursePictureURL, nil
}

// ClearCoursePictureURL clears the value of the "course_picture_url" field.
func (m *CourseMutation) ClearCoursePictureURL() {
	m.course_picture_url = nil
	m.clearedFields[course.FieldCoursePictureURL] = struct{}{}
}

// CoursePictureURLCleared returns if the "course_picture_url" field was cleared in this mutation.
func (m *CourseMutation) CoursePictureURLCleared() bool {
	_, ok := m.clearedFields[course.FieldCoursePictureURL]
	return ok
}

// ResetCoursePictureURL resets all changes to the "course_picture_url" field.
func (m *CourseMutation) ResetCoursePictureURL() {
	m.course_picture_url = nil
	delete(m.clearedFields, course.FieldCoursePictureURL)
}

// AddReviewCourseIDs adds the "review_course" edge to the ReviewCourse entity by ids.
func (m *CourseMutation) AddReviewCourseIDs(ids ...int) {
	if m.review_course == nil {
		m.review_course = make(map[int]struct{})
	}
	for i := range ids {
		m.review_course[ids[i]] = struct{}{}
	}
}

// ClearReviewCourse clears the "review_course" edge to the ReviewCourse entity.
func (m *CourseMutation) ClearReviewCourse() {
	m.clearedreview_course = true
}

// ReviewCourseCleared reports if the "review_course" edge to the ReviewCourse entity was cleared.
func (m *CourseMutation) ReviewCourseCleared() bool {
	return m.clearedreview_course
}

// RemoveReviewCourseIDs removes the "review_course" edge to the ReviewCourse entity by IDs.
func (m *CourseMutation) RemoveReviewCourseIDs(ids ...int) {
	if m.removedreview_course == nil {
		m.removedreview_course = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.review_course, ids[i])
		m.removedreview_course[ids[i]] = struct{}{}
	}
}

// RemovedReviewCourse returns the removed IDs of the "review_course" edge to the ReviewCourse entity.
func (m *CourseMutation) RemovedReviewCourseIDs() (ids []int) {
	for id := range m.removedreview_course {
		ids = append(ids, id)
	}
	return
}

// ReviewCourseIDs returns the "review_course" edge IDs in the mutation.
func (m *CourseMutation) ReviewCourseIDs() (ids []int) {
	for id := range m.review_course {
		ids = append(ids, id)
	}
	return
}

// ResetReviewCourse resets all changes to the "review_course" edge.
func (m *CourseMutation) ResetReviewCourse() {
	m.review_course = nil
	m.clearedreview_course = false
	m.removedreview_course = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *CourseMutation) SetClassID(id uuid.UUID) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *CourseMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *CourseMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *CourseMutation) ClassID() (id uuid.UUID, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) ClassIDs() (ids []uuid.UUID) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *CourseMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *CourseMutation) SetStudentID(id uuid.UUID) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *CourseMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *CourseMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *CourseMutation) StudentID() (id uuid.UUID, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) StudentIDs() (ids []uuid.UUID) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *CourseMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *CourseMutation) SetTutorID(id uuid.UUID) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *CourseMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *CourseMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *CourseMutation) TutorID() (id uuid.UUID, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) TutorIDs() (ids []uuid.UUID) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *CourseMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.title != nil {
		fields = append(fields, course.FieldTitle)
	}
	if m.estimated_time != nil {
		fields = append(fields, course.FieldEstimatedTime)
	}
	if m.description != nil {
		fields = append(fields, course.FieldDescription)
	}
	if m.course_status != nil {
		fields = append(fields, course.FieldCourseStatus)
	}
	if m.price_per_hour != nil {
		fields = append(fields, course.FieldPricePerHour)
	}
	if m.level_id != nil {
		fields = append(fields, course.FieldLevelID)
	}
	if m.course_picture_url != nil {
		fields = append(fields, course.FieldCoursePictureURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldTitle:
		return m.Title()
	case course.FieldEstimatedTime:
		return m.EstimatedTime()
	case course.FieldDescription:
		return m.Description()
	case course.FieldCourseStatus:
		return m.CourseStatus()
	case course.FieldPricePerHour:
		return m.PricePerHour()
	case course.FieldLevelID:
		return m.LevelID()
	case course.FieldCoursePictureURL:
		return m.CoursePictureURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldTitle:
		return m.OldTitle(ctx)
	case course.FieldEstimatedTime:
		return m.OldEstimatedTime(ctx)
	case course.FieldDescription:
		return m.OldDescription(ctx)
	case course.FieldCourseStatus:
		return m.OldCourseStatus(ctx)
	case course.FieldPricePerHour:
		return m.OldPricePerHour(ctx)
	case course.FieldLevelID:
		return m.OldLevelID(ctx)
	case course.FieldCoursePictureURL:
		return m.OldCoursePictureURL(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case course.FieldEstimatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedTime(v)
		return nil
	case course.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case course.FieldCourseStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseStatus(v)
		return nil
	case course.FieldPricePerHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePerHour(v)
		return nil
	case course.FieldLevelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelID(v)
		return nil
	case course.FieldCoursePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoursePictureURL(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	if m.addprice_per_hour != nil {
		fields = append(fields, course.FieldPricePerHour)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case course.FieldPricePerHour:
		return m.AddedPricePerHour()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case course.FieldPricePerHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPricePerHour(v)
		return nil
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(course.FieldCoursePictureURL) {
		fields = append(fields, course.FieldCoursePictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	switch name {
	case course.FieldCoursePictureURL:
		m.ClearCoursePictureURL()
		return nil
	}
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldTitle:
		m.ResetTitle()
		return nil
	case course.FieldEstimatedTime:
		m.ResetEstimatedTime()
		return nil
	case course.FieldDescription:
		m.ResetDescription()
		return nil
	case course.FieldCourseStatus:
		m.ResetCourseStatus()
		return nil
	case course.FieldPricePerHour:
		m.ResetPricePerHour()
		return nil
	case course.FieldLevelID:
		m.ResetLevelID()
		return nil
	case course.FieldCoursePictureURL:
		m.ResetCoursePictureURL()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.review_course != nil {
		edges = append(edges, course.EdgeReviewCourse)
	}
	if m.class != nil {
		edges = append(edges, course.EdgeClass)
	}
	if m.student != nil {
		edges = append(edges, course.EdgeStudent)
	}
	if m.tutor != nil {
		edges = append(edges, course.EdgeTutor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeReviewCourse:
		ids := make([]ent.Value, 0, len(m.review_course))
		for id := range m.review_course {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedreview_course != nil {
		edges = append(edges, course.EdgeReviewCourse)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeReviewCourse:
		ids := make([]ent.Value, 0, len(m.removedreview_course))
		for id := range m.removedreview_course {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedreview_course {
		edges = append(edges, course.EdgeReviewCourse)
	}
	if m.clearedclass {
		edges = append(edges, course.EdgeClass)
	}
	if m.clearedstudent {
		edges = append(edges, course.EdgeStudent)
	}
	if m.clearedtutor {
		edges = append(edges, course.EdgeTutor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeReviewCourse:
		return m.clearedreview_course
	case course.EdgeClass:
		return m.clearedclass
	case course.EdgeStudent:
		return m.clearedstudent
	case course.EdgeTutor:
		return m.clearedtutor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeClass:
		m.ClearClass()
		return nil
	case course.EdgeStudent:
		m.ClearStudent()
		return nil
	case course.EdgeTutor:
		m.ClearTutor()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeReviewCourse:
		m.ResetReviewCourse()
		return nil
	case course.EdgeClass:
		m.ResetClass()
		return nil
	case course.EdgeStudent:
		m.ResetStudent()
		return nil
	case course.EdgeTutor:
		m.ResetTutor()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// IssueReportMutation represents an operation that mutates the IssueReport nodes in the graph.
type IssueReportMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	title          *string
	description    *string
	report_date    *time.Time
	status         *string
	clearedFields  map[string]struct{}
	student        *uuid.UUID
	clearedstudent bool
	tutor          *uuid.UUID
	clearedtutor   bool
	done           bool
	oldValue       func(context.Context) (*IssueReport, error)
	predicates     []predicate.IssueReport
}

var _ ent.Mutation = (*IssueReportMutation)(nil)

// issuereportOption allows management of the mutation configuration using functional options.
type issuereportOption func(*IssueReportMutation)

// newIssueReportMutation creates new mutation for the IssueReport entity.
func newIssueReportMutation(c config, op Op, opts ...issuereportOption) *IssueReportMutation {
	m := &IssueReportMutation{
		config:        c,
		op:            op,
		typ:           TypeIssueReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssueReportID sets the ID field of the mutation.
func withIssueReportID(id uuid.UUID) issuereportOption {
	return func(m *IssueReportMutation) {
		var (
			err   error
			once  sync.Once
			value *IssueReport
		)
		m.oldValue = func(ctx context.Context) (*IssueReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IssueReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssueReport sets the old IssueReport of the mutation.
func withIssueReport(node *IssueReport) issuereportOption {
	return func(m *IssueReportMutation) {
		m.oldValue = func(context.Context) (*IssueReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssueReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssueReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IssueReport entities.
func (m *IssueReportMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssueReportMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssueReportMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IssueReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *IssueReportMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IssueReportMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IssueReportMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IssueReportMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IssueReportMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *IssueReportMutation) ResetDescription() {
	m.description = nil
}

// SetReportDate sets the "report_date" field.
func (m *IssueReportMutation) SetReportDate(t time.Time) {
	m.report_date = &t
}

// ReportDate returns the value of the "report_date" field in the mutation.
func (m *IssueReportMutation) ReportDate() (r time.Time, exists bool) {
	v := m.report_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReportDate returns the old "report_date" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldReportDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportDate: %w", err)
	}
	return oldValue.ReportDate, nil
}

// ResetReportDate resets all changes to the "report_date" field.
func (m *IssueReportMutation) ResetReportDate() {
	m.report_date = nil
}

// SetStatus sets the "status" field.
func (m *IssueReportMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *IssueReportMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IssueReportMutation) ResetStatus() {
	m.status = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *IssueReportMutation) SetStudentID(id uuid.UUID) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *IssueReportMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *IssueReportMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *IssueReportMutation) StudentID() (id uuid.UUID, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *IssueReportMutation) StudentIDs() (ids []uuid.UUID) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *IssueReportMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *IssueReportMutation) SetTutorID(id uuid.UUID) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *IssueReportMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *IssueReportMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *IssueReportMutation) TutorID() (id uuid.UUID, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *IssueReportMutation) TutorIDs() (ids []uuid.UUID) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *IssueReportMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// Where appends a list predicates to the IssueReportMutation builder.
func (m *IssueReportMutation) Where(ps ...predicate.IssueReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssueReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssueReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IssueReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssueReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssueReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IssueReport).
func (m *IssueReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssueReportMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.title != nil {
		fields = append(fields, issuereport.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, issuereport.FieldDescription)
	}
	if m.report_date != nil {
		fields = append(fields, issuereport.FieldReportDate)
	}
	if m.status != nil {
		fields = append(fields, issuereport.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssueReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case issuereport.FieldTitle:
		return m.Title()
	case issuereport.FieldDescription:
		return m.Description()
	case issuereport.FieldReportDate:
		return m.ReportDate()
	case issuereport.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssueReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case issuereport.FieldTitle:
		return m.OldTitle(ctx)
	case issuereport.FieldDescription:
		return m.OldDescription(ctx)
	case issuereport.FieldReportDate:
		return m.OldReportDate(ctx)
	case issuereport.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown IssueReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case issuereport.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case issuereport.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case issuereport.FieldReportDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportDate(v)
		return nil
	case issuereport.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown IssueReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssueReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssueReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IssueReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssueReportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssueReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssueReportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IssueReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssueReportMutation) ResetField(name string) error {
	switch name {
	case issuereport.FieldTitle:
		m.ResetTitle()
		return nil
	case issuereport.FieldDescription:
		m.ResetDescription()
		return nil
	case issuereport.FieldReportDate:
		m.ResetReportDate()
		return nil
	case issuereport.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown IssueReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssueReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.student != nil {
		edges = append(edges, issuereport.EdgeStudent)
	}
	if m.tutor != nil {
		edges = append(edges, issuereport.EdgeTutor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssueReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case issuereport.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case issuereport.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssueReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssueReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssueReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudent {
		edges = append(edges, issuereport.EdgeStudent)
	}
	if m.clearedtutor {
		edges = append(edges, issuereport.EdgeTutor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssueReportMutation) EdgeCleared(name string) bool {
	switch name {
	case issuereport.EdgeStudent:
		return m.clearedstudent
	case issuereport.EdgeTutor:
		return m.clearedtutor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssueReportMutation) ClearEdge(name string) error {
	switch name {
	case issuereport.EdgeStudent:
		m.ClearStudent()
		return nil
	case issuereport.EdgeTutor:
		m.ClearTutor()
		return nil
	}
	return fmt.Errorf("unknown IssueReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssueReportMutation) ResetEdge(name string) error {
	switch name {
	case issuereport.EdgeStudent:
		m.ResetStudent()
		return nil
	case issuereport.EdgeTutor:
		m.ResetTutor()
		return nil
	}
	return fmt.Errorf("unknown IssueReport edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	qr_picture_url *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Payment, error)
	predicates     []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id uuid.UUID) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payment entities.
func (m *PaymentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQrPictureURL sets the "qr_picture_url" field.
func (m *PaymentMutation) SetQrPictureURL(s string) {
	m.qr_picture_url = &s
}

// QrPictureURL returns the value of the "qr_picture_url" field in the mutation.
func (m *PaymentMutation) QrPictureURL() (r string, exists bool) {
	v := m.qr_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldQrPictureURL returns the old "qr_picture_url" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldQrPictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrPictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrPictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrPictureURL: %w", err)
	}
	return oldValue.QrPictureURL, nil
}

// ClearQrPictureURL clears the value of the "qr_picture_url" field.
func (m *PaymentMutation) ClearQrPictureURL() {
	m.qr_picture_url = nil
	m.clearedFields[payment.FieldQrPictureURL] = struct{}{}
}

// QrPictureURLCleared returns if the "qr_picture_url" field was cleared in this mutation.
func (m *PaymentMutation) QrPictureURLCleared() bool {
	_, ok := m.clearedFields[payment.FieldQrPictureURL]
	return ok
}

// ResetQrPictureURL resets all changes to the "qr_picture_url" field.
func (m *PaymentMutation) ResetQrPictureURL() {
	m.qr_picture_url = nil
	delete(m.clearedFields, payment.FieldQrPictureURL)
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.qr_picture_url != nil {
		fields = append(fields, payment.FieldQrPictureURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldQrPictureURL:
		return m.QrPictureURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldQrPictureURL:
		return m.OldQrPictureURL(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldQrPictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrPictureURL(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment.FieldQrPictureURL) {
		fields = append(fields, payment.FieldQrPictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	switch name {
	case payment.FieldQrPictureURL:
		m.ClearQrPictureURL()
		return nil
	}
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldQrPictureURL:
		m.ResetQrPictureURL()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PaymentHistoryMutation represents an operation that mutates the PaymentHistory nodes in the graph.
type PaymentHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	amount        *float64
	addamount     *float64
	_type         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PaymentHistory, error)
	predicates    []predicate.PaymentHistory
}

var _ ent.Mutation = (*PaymentHistoryMutation)(nil)

// paymenthistoryOption allows management of the mutation configuration using functional options.
type paymenthistoryOption func(*PaymentHistoryMutation)

// newPaymentHistoryMutation creates new mutation for the PaymentHistory entity.
func newPaymentHistoryMutation(c config, op Op, opts ...paymenthistoryOption) *PaymentHistoryMutation {
	m := &PaymentHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentHistoryID sets the ID field of the mutation.
func withPaymentHistoryID(id uuid.UUID) paymenthistoryOption {
	return func(m *PaymentHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentHistory
		)
		m.oldValue = func(ctx context.Context) (*PaymentHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentHistory sets the old PaymentHistory of the mutation.
func withPaymentHistory(node *PaymentHistory) paymenthistoryOption {
	return func(m *PaymentHistoryMutation) {
		m.oldValue = func(context.Context) (*PaymentHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentHistory entities.
func (m *PaymentHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *PaymentHistoryMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentHistoryMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentHistory entity.
// If the PaymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentHistoryMutation) OldAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PaymentHistoryMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentHistoryMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *PaymentHistoryMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[paymenthistory.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *PaymentHistoryMutation) AmountCleared() bool {
	_, ok := m.clearedFields[paymenthistory.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentHistoryMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, paymenthistory.FieldAmount)
}

// SetType sets the "type" field.
func (m *PaymentHistoryMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PaymentHistoryMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PaymentHistory entity.
// If the PaymentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentHistoryMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PaymentHistoryMutation) ResetType() {
	m._type = nil
}

// Where appends a list predicates to the PaymentHistoryMutation builder.
func (m *PaymentHistoryMutation) Where(ps ...predicate.PaymentHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentHistory).
func (m *PaymentHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentHistoryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.amount != nil {
		fields = append(fields, paymenthistory.FieldAmount)
	}
	if m._type != nil {
		fields = append(fields, paymenthistory.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymenthistory.FieldAmount:
		return m.Amount()
	case paymenthistory.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymenthistory.FieldAmount:
		return m.OldAmount(ctx)
	case paymenthistory.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymenthistory.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymenthistory.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, paymenthistory.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymenthistory.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymenthistory.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymenthistory.FieldAmount) {
		fields = append(fields, paymenthistory.FieldAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentHistoryMutation) ClearField(name string) error {
	switch name {
	case paymenthistory.FieldAmount:
		m.ClearAmount()
		return nil
	}
	return fmt.Errorf("unknown PaymentHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentHistoryMutation) ResetField(name string) error {
	switch name {
	case paymenthistory.FieldAmount:
		m.ResetAmount()
		return nil
	case paymenthistory.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown PaymentHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PaymentHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PaymentHistory edge %s", name)
}

// ReviewCourseMutation represents an operation that mutates the ReviewCourse nodes in the graph.
type ReviewCourseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	score         *float32
	addscore      *float32
	review_msg    *string
	clearedFields map[string]struct{}
	course        *uuid.UUID
	clearedcourse bool
	done          bool
	oldValue      func(context.Context) (*ReviewCourse, error)
	predicates    []predicate.ReviewCourse
}

var _ ent.Mutation = (*ReviewCourseMutation)(nil)

// reviewcourseOption allows management of the mutation configuration using functional options.
type reviewcourseOption func(*ReviewCourseMutation)

// newReviewCourseMutation creates new mutation for the ReviewCourse entity.
func newReviewCourseMutation(c config, op Op, opts ...reviewcourseOption) *ReviewCourseMutation {
	m := &ReviewCourseMutation{
		config:        c,
		op:            op,
		typ:           TypeReviewCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewCourseID sets the ID field of the mutation.
func withReviewCourseID(id int) reviewcourseOption {
	return func(m *ReviewCourseMutation) {
		var (
			err   error
			once  sync.Once
			value *ReviewCourse
		)
		m.oldValue = func(ctx context.Context) (*ReviewCourse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReviewCourse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReviewCourse sets the old ReviewCourse of the mutation.
func withReviewCourse(node *ReviewCourse) reviewcourseOption {
	return func(m *ReviewCourseMutation) {
		m.oldValue = func(context.Context) (*ReviewCourse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewCourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewCourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewCourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewCourseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReviewCourse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScore sets the "score" field.
func (m *ReviewCourseMutation) SetScore(f float32) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ReviewCourseMutation) Score() (r float32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ReviewCourse entity.
// If the ReviewCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCourseMutation) OldScore(ctx context.Context) (v *float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *ReviewCourseMutation) AddScore(f float32) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ReviewCourseMutation) AddedScore() (r float32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *ReviewCourseMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[reviewcourse.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ReviewCourseMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[reviewcourse.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ReviewCourseMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, reviewcourse.FieldScore)
}

// SetReviewMsg sets the "review_msg" field.
func (m *ReviewCourseMutation) SetReviewMsg(s string) {
	m.review_msg = &s
}

// ReviewMsg returns the value of the "review_msg" field in the mutation.
func (m *ReviewCourseMutation) ReviewMsg() (r string, exists bool) {
	v := m.review_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewMsg returns the old "review_msg" field's value of the ReviewCourse entity.
// If the ReviewCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewCourseMutation) OldReviewMsg(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewMsg: %w", err)
	}
	return oldValue.ReviewMsg, nil
}

// ClearReviewMsg clears the value of the "review_msg" field.
func (m *ReviewCourseMutation) ClearReviewMsg() {
	m.review_msg = nil
	m.clearedFields[reviewcourse.FieldReviewMsg] = struct{}{}
}

// ReviewMsgCleared returns if the "review_msg" field was cleared in this mutation.
func (m *ReviewCourseMutation) ReviewMsgCleared() bool {
	_, ok := m.clearedFields[reviewcourse.FieldReviewMsg]
	return ok
}

// ResetReviewMsg resets all changes to the "review_msg" field.
func (m *ReviewCourseMutation) ResetReviewMsg() {
	m.review_msg = nil
	delete(m.clearedFields, reviewcourse.FieldReviewMsg)
}

// SetCourseID sets the "course" edge to the Course entity by id.
func (m *ReviewCourseMutation) SetCourseID(id uuid.UUID) {
	m.course = &id
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *ReviewCourseMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *ReviewCourseMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the "course" edge ID in the mutation.
func (m *ReviewCourseMutation) CourseID() (id uuid.UUID, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *ReviewCourseMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ReviewCourseMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// Where appends a list predicates to the ReviewCourseMutation builder.
func (m *ReviewCourseMutation) Where(ps ...predicate.ReviewCourse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewCourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewCourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReviewCourse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewCourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewCourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReviewCourse).
func (m *ReviewCourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewCourseMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.score != nil {
		fields = append(fields, reviewcourse.FieldScore)
	}
	if m.review_msg != nil {
		fields = append(fields, reviewcourse.FieldReviewMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewCourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reviewcourse.FieldScore:
		return m.Score()
	case reviewcourse.FieldReviewMsg:
		return m.ReviewMsg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewCourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reviewcourse.FieldScore:
		return m.OldScore(ctx)
	case reviewcourse.FieldReviewMsg:
		return m.OldReviewMsg(ctx)
	}
	return nil, fmt.Errorf("unknown ReviewCourse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewCourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reviewcourse.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case reviewcourse.FieldReviewMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewMsg(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewCourseMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, reviewcourse.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewCourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reviewcourse.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewCourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reviewcourse.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewCourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reviewcourse.FieldScore) {
		fields = append(fields, reviewcourse.FieldScore)
	}
	if m.FieldCleared(reviewcourse.FieldReviewMsg) {
		fields = append(fields, reviewcourse.FieldReviewMsg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewCourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewCourseMutation) ClearField(name string) error {
	switch name {
	case reviewcourse.FieldScore:
		m.ClearScore()
		return nil
	case reviewcourse.FieldReviewMsg:
		m.ClearReviewMsg()
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewCourseMutation) ResetField(name string) error {
	switch name {
	case reviewcourse.FieldScore:
		m.ResetScore()
		return nil
	case reviewcourse.FieldReviewMsg:
		m.ResetReviewMsg()
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewCourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.course != nil {
		edges = append(edges, reviewcourse.EdgeCourse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewCourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reviewcourse.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewCourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewCourseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewCourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcourse {
		edges = append(edges, reviewcourse.EdgeCourse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewCourseMutation) EdgeCleared(name string) bool {
	switch name {
	case reviewcourse.EdgeCourse:
		return m.clearedcourse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewCourseMutation) ClearEdge(name string) error {
	switch name {
	case reviewcourse.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewCourseMutation) ResetEdge(name string) error {
	switch name {
	case reviewcourse.EdgeCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown ReviewCourse edge %s", name)
}

// ReviewTutorMutation represents an operation that mutates the ReviewTutor nodes in the graph.
type ReviewTutorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	score         *float32
	addscore      *float32
	review_msg    *string
	clearedFields map[string]struct{}
	tutor         *uuid.UUID
	clearedtutor  bool
	done          bool
	oldValue      func(context.Context) (*ReviewTutor, error)
	predicates    []predicate.ReviewTutor
}

var _ ent.Mutation = (*ReviewTutorMutation)(nil)

// reviewtutorOption allows management of the mutation configuration using functional options.
type reviewtutorOption func(*ReviewTutorMutation)

// newReviewTutorMutation creates new mutation for the ReviewTutor entity.
func newReviewTutorMutation(c config, op Op, opts ...reviewtutorOption) *ReviewTutorMutation {
	m := &ReviewTutorMutation{
		config:        c,
		op:            op,
		typ:           TypeReviewTutor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewTutorID sets the ID field of the mutation.
func withReviewTutorID(id int) reviewtutorOption {
	return func(m *ReviewTutorMutation) {
		var (
			err   error
			once  sync.Once
			value *ReviewTutor
		)
		m.oldValue = func(ctx context.Context) (*ReviewTutor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReviewTutor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReviewTutor sets the old ReviewTutor of the mutation.
func withReviewTutor(node *ReviewTutor) reviewtutorOption {
	return func(m *ReviewTutorMutation) {
		m.oldValue = func(context.Context) (*ReviewTutor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewTutorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewTutorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewTutorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewTutorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReviewTutor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScore sets the "score" field.
func (m *ReviewTutorMutation) SetScore(f float32) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ReviewTutorMutation) Score() (r float32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ReviewTutor entity.
// If the ReviewTutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewTutorMutation) OldScore(ctx context.Context) (v *float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *ReviewTutorMutation) AddScore(f float32) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ReviewTutorMutation) AddedScore() (r float32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *ReviewTutorMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[reviewtutor.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ReviewTutorMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[reviewtutor.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ReviewTutorMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, reviewtutor.FieldScore)
}

// SetReviewMsg sets the "review_msg" field.
func (m *ReviewTutorMutation) SetReviewMsg(s string) {
	m.review_msg = &s
}

// ReviewMsg returns the value of the "review_msg" field in the mutation.
func (m *ReviewTutorMutation) ReviewMsg() (r string, exists bool) {
	v := m.review_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewMsg returns the old "review_msg" field's value of the ReviewTutor entity.
// If the ReviewTutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewTutorMutation) OldReviewMsg(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewMsg: %w", err)
	}
	return oldValue.ReviewMsg, nil
}

// ClearReviewMsg clears the value of the "review_msg" field.
func (m *ReviewTutorMutation) ClearReviewMsg() {
	m.review_msg = nil
	m.clearedFields[reviewtutor.FieldReviewMsg] = struct{}{}
}

// ReviewMsgCleared returns if the "review_msg" field was cleared in this mutation.
func (m *ReviewTutorMutation) ReviewMsgCleared() bool {
	_, ok := m.clearedFields[reviewtutor.FieldReviewMsg]
	return ok
}

// ResetReviewMsg resets all changes to the "review_msg" field.
func (m *ReviewTutorMutation) ResetReviewMsg() {
	m.review_msg = nil
	delete(m.clearedFields, reviewtutor.FieldReviewMsg)
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *ReviewTutorMutation) SetTutorID(id uuid.UUID) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *ReviewTutorMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *ReviewTutorMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *ReviewTutorMutation) TutorID() (id uuid.UUID, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *ReviewTutorMutation) TutorIDs() (ids []uuid.UUID) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *ReviewTutorMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// Where appends a list predicates to the ReviewTutorMutation builder.
func (m *ReviewTutorMutation) Where(ps ...predicate.ReviewTutor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewTutorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewTutorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReviewTutor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewTutorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewTutorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReviewTutor).
func (m *ReviewTutorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewTutorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.score != nil {
		fields = append(fields, reviewtutor.FieldScore)
	}
	if m.review_msg != nil {
		fields = append(fields, reviewtutor.FieldReviewMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewTutorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reviewtutor.FieldScore:
		return m.Score()
	case reviewtutor.FieldReviewMsg:
		return m.ReviewMsg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewTutorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reviewtutor.FieldScore:
		return m.OldScore(ctx)
	case reviewtutor.FieldReviewMsg:
		return m.OldReviewMsg(ctx)
	}
	return nil, fmt.Errorf("unknown ReviewTutor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewTutorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reviewtutor.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case reviewtutor.FieldReviewMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewMsg(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewTutorMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, reviewtutor.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewTutorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reviewtutor.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewTutorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reviewtutor.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewTutorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reviewtutor.FieldScore) {
		fields = append(fields, reviewtutor.FieldScore)
	}
	if m.FieldCleared(reviewtutor.FieldReviewMsg) {
		fields = append(fields, reviewtutor.FieldReviewMsg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewTutorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewTutorMutation) ClearField(name string) error {
	switch name {
	case reviewtutor.FieldScore:
		m.ClearScore()
		return nil
	case reviewtutor.FieldReviewMsg:
		m.ClearReviewMsg()
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewTutorMutation) ResetField(name string) error {
	switch name {
	case reviewtutor.FieldScore:
		m.ResetScore()
		return nil
	case reviewtutor.FieldReviewMsg:
		m.ResetReviewMsg()
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewTutorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tutor != nil {
		edges = append(edges, reviewtutor.EdgeTutor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewTutorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reviewtutor.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewTutorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewTutorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewTutorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtutor {
		edges = append(edges, reviewtutor.EdgeTutor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewTutorMutation) EdgeCleared(name string) bool {
	switch name {
	case reviewtutor.EdgeTutor:
		return m.clearedtutor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewTutorMutation) ClearEdge(name string) error {
	switch name {
	case reviewtutor.EdgeTutor:
		m.ClearTutor()
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewTutorMutation) ResetEdge(name string) error {
	switch name {
	case reviewtutor.EdgeTutor:
		m.ResetTutor()
		return nil
	}
	return fmt.Errorf("unknown ReviewTutor edge %s", name)
}

// ScheduleMutation represents an operation that mutates the Schedule nodes in the graph.
type ScheduleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	day_0         *bool
	day_1         *bool
	day_2         *bool
	day_3         *bool
	day_4         *bool
	day_5         *bool
	day_6         *bool
	clearedFields map[string]struct{}
	tutor         *uuid.UUID
	clearedtutor  bool
	class         *uuid.UUID
	clearedclass  bool
	done          bool
	oldValue      func(context.Context) (*Schedule, error)
	predicates    []predicate.Schedule
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows management of the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for the Schedule entity.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the ID field of the mutation.
func withScheduleID(id uuid.UUID) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Schedule entities.
func (m *ScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Schedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDay0 sets the "day_0" field.
func (m *ScheduleMutation) SetDay0(b bool) {
	m.day_0 = &b
}

// Day0 returns the value of the "day_0" field in the mutation.
func (m *ScheduleMutation) Day0() (r bool, exists bool) {
	v := m.day_0
	if v == nil {
		return
	}
	return *v, true
}

// OldDay0 returns the old "day_0" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay0(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay0 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay0 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay0: %w", err)
	}
	return oldValue.Day0, nil
}

// ClearDay0 clears the value of the "day_0" field.
func (m *ScheduleMutation) ClearDay0() {
	m.day_0 = nil
	m.clearedFields[schedule.FieldDay0] = struct{}{}
}

// Day0Cleared returns if the "day_0" field was cleared in this mutation.
func (m *ScheduleMutation) Day0Cleared() bool {
	_, ok := m.clearedFields[schedule.FieldDay0]
	return ok
}

// ResetDay0 resets all changes to the "day_0" field.
func (m *ScheduleMutation) ResetDay0() {
	m.day_0 = nil
	delete(m.clearedFields, schedule.FieldDay0)
}

// SetDay1 sets the "day_1" field.
func (m *ScheduleMutation) SetDay1(b bool) {
	m.day_1 = &b
}

// Day1 returns the value of the "day_1" field in the mutation.
func (m *ScheduleMutation) Day1() (r bool, exists bool) {
	v := m.day_1
	if v == nil {
		return
	}
	return *v, true
}

// OldDay1 returns the old "day_1" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay1(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay1: %w", err)
	}
	return oldValue.Day1, nil
}

// ClearDay1 clears the value of the "day_1" field.
func (m *ScheduleMutation) ClearDay1() {
	m.day_1 = nil
	m.clearedFields[schedule.FieldDay1] = struct{}{}
}

// Day1Cleared returns if the "day_1" field was cleared in this mutation.
func (m *ScheduleMutation) Day1Cleared() bool {
	_, ok := m.clearedFields[schedule.FieldDay1]
	return ok
}

// ResetDay1 resets all changes to the "day_1" field.
func (m *ScheduleMutation) ResetDay1() {
	m.day_1 = nil
	delete(m.clearedFields, schedule.FieldDay1)
}

// SetDay2 sets the "day_2" field.
func (m *ScheduleMutation) SetDay2(b bool) {
	m.day_2 = &b
}

// Day2 returns the value of the "day_2" field in the mutation.
func (m *ScheduleMutation) Day2() (r bool, exists bool) {
	v := m.day_2
	if v == nil {
		return
	}
	return *v, true
}

// OldDay2 returns the old "day_2" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay2(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay2: %w", err)
	}
	return oldValue.Day2, nil
}

// ClearDay2 clears the value of the "day_2" field.
func (m *ScheduleMutation) ClearDay2() {
	m.day_2 = nil
	m.clearedFields[schedule.FieldDay2] = struct{}{}
}

// Day2Cleared returns if the "day_2" field was cleared in this mutation.
func (m *ScheduleMutation) Day2Cleared() bool {
	_, ok := m.clearedFields[schedule.FieldDay2]
	return ok
}

// ResetDay2 resets all changes to the "day_2" field.
func (m *ScheduleMutation) ResetDay2() {
	m.day_2 = nil
	delete(m.clearedFields, schedule.FieldDay2)
}

// SetDay3 sets the "day_3" field.
func (m *ScheduleMutation) SetDay3(b bool) {
	m.day_3 = &b
}

// Day3 returns the value of the "day_3" field in the mutation.
func (m *ScheduleMutation) Day3() (r bool, exists bool) {
	v := m.day_3
	if v == nil {
		return
	}
	return *v, true
}

// OldDay3 returns the old "day_3" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay3(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay3: %w", err)
	}
	return oldValue.Day3, nil
}

// ClearDay3 clears the value of the "day_3" field.
func (m *ScheduleMutation) ClearDay3() {
	m.day_3 = nil
	m.clearedFields[schedule.FieldDay3] = struct{}{}
}

// Day3Cleared returns if the "day_3" field was cleared in this mutation.
func (m *ScheduleMutation) Day3Cleared() bool {
	_, ok := m.clearedFields[schedule.FieldDay3]
	return ok
}

// ResetDay3 resets all changes to the "day_3" field.
func (m *ScheduleMutation) ResetDay3() {
	m.day_3 = nil
	delete(m.clearedFields, schedule.FieldDay3)
}

// SetDay4 sets the "day_4" field.
func (m *ScheduleMutation) SetDay4(b bool) {
	m.day_4 = &b
}

// Day4 returns the value of the "day_4" field in the mutation.
func (m *ScheduleMutation) Day4() (r bool, exists bool) {
	v := m.day_4
	if v == nil {
		return
	}
	return *v, true
}

// OldDay4 returns the old "day_4" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay4(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay4: %w", err)
	}
	return oldValue.Day4, nil
}

// ClearDay4 clears the value of the "day_4" field.
func (m *ScheduleMutation) ClearDay4() {
	m.day_4 = nil
	m.clearedFields[schedule.FieldDay4] = struct{}{}
}

// Day4Cleared returns if the "day_4" field was cleared in this mutation.
func (m *ScheduleMutation) Day4Cleared() bool {
	_, ok := m.clearedFields[schedule.FieldDay4]
	return ok
}

// ResetDay4 resets all changes to the "day_4" field.
func (m *ScheduleMutation) ResetDay4() {
	m.day_4 = nil
	delete(m.clearedFields, schedule.FieldDay4)
}

// SetDay5 sets the "day_5" field.
func (m *ScheduleMutation) SetDay5(b bool) {
	m.day_5 = &b
}

// Day5 returns the value of the "day_5" field in the mutation.
func (m *ScheduleMutation) Day5() (r bool, exists bool) {
	v := m.day_5
	if v == nil {
		return
	}
	return *v, true
}

// OldDay5 returns the old "day_5" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay5(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay5: %w", err)
	}
	return oldValue.Day5, nil
}

// ClearDay5 clears the value of the "day_5" field.
func (m *ScheduleMutation) ClearDay5() {
	m.day_5 = nil
	m.clearedFields[schedule.FieldDay5] = struct{}{}
}

// Day5Cleared returns if the "day_5" field was cleared in this mutation.
func (m *ScheduleMutation) Day5Cleared() bool {
	_, ok := m.clearedFields[schedule.FieldDay5]
	return ok
}

// ResetDay5 resets all changes to the "day_5" field.
func (m *ScheduleMutation) ResetDay5() {
	m.day_5 = nil
	delete(m.clearedFields, schedule.FieldDay5)
}

// SetDay6 sets the "day_6" field.
func (m *ScheduleMutation) SetDay6(b bool) {
	m.day_6 = &b
}

// Day6 returns the value of the "day_6" field in the mutation.
func (m *ScheduleMutation) Day6() (r bool, exists bool) {
	v := m.day_6
	if v == nil {
		return
	}
	return *v, true
}

// OldDay6 returns the old "day_6" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay6(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay6: %w", err)
	}
	return oldValue.Day6, nil
}

// ClearDay6 clears the value of the "day_6" field.
func (m *ScheduleMutation) ClearDay6() {
	m.day_6 = nil
	m.clearedFields[schedule.FieldDay6] = struct{}{}
}

// Day6Cleared returns if the "day_6" field was cleared in this mutation.
func (m *ScheduleMutation) Day6Cleared() bool {
	_, ok := m.clearedFields[schedule.FieldDay6]
	return ok
}

// ResetDay6 resets all changes to the "day_6" field.
func (m *ScheduleMutation) ResetDay6() {
	m.day_6 = nil
	delete(m.clearedFields, schedule.FieldDay6)
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *ScheduleMutation) SetTutorID(id uuid.UUID) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *ScheduleMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *ScheduleMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *ScheduleMutation) TutorID() (id uuid.UUID, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) TutorIDs() (ids []uuid.UUID) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *ScheduleMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *ScheduleMutation) SetClassID(id uuid.UUID) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ScheduleMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ScheduleMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *ScheduleMutation) ClassID() (id uuid.UUID, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) ClassIDs() (ids []uuid.UUID) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ScheduleMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the ScheduleMutation builder.
func (m *ScheduleMutation) Where(ps ...predicate.Schedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Schedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.day_0 != nil {
		fields = append(fields, schedule.FieldDay0)
	}
	if m.day_1 != nil {
		fields = append(fields, schedule.FieldDay1)
	}
	if m.day_2 != nil {
		fields = append(fields, schedule.FieldDay2)
	}
	if m.day_3 != nil {
		fields = append(fields, schedule.FieldDay3)
	}
	if m.day_4 != nil {
		fields = append(fields, schedule.FieldDay4)
	}
	if m.day_5 != nil {
		fields = append(fields, schedule.FieldDay5)
	}
	if m.day_6 != nil {
		fields = append(fields, schedule.FieldDay6)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldDay0:
		return m.Day0()
	case schedule.FieldDay1:
		return m.Day1()
	case schedule.FieldDay2:
		return m.Day2()
	case schedule.FieldDay3:
		return m.Day3()
	case schedule.FieldDay4:
		return m.Day4()
	case schedule.FieldDay5:
		return m.Day5()
	case schedule.FieldDay6:
		return m.Day6()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldDay0:
		return m.OldDay0(ctx)
	case schedule.FieldDay1:
		return m.OldDay1(ctx)
	case schedule.FieldDay2:
		return m.OldDay2(ctx)
	case schedule.FieldDay3:
		return m.OldDay3(ctx)
	case schedule.FieldDay4:
		return m.OldDay4(ctx)
	case schedule.FieldDay5:
		return m.OldDay5(ctx)
	case schedule.FieldDay6:
		return m.OldDay6(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldDay0:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay0(v)
		return nil
	case schedule.FieldDay1:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay1(v)
		return nil
	case schedule.FieldDay2:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay2(v)
		return nil
	case schedule.FieldDay3:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay3(v)
		return nil
	case schedule.FieldDay4:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay4(v)
		return nil
	case schedule.FieldDay5:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay5(v)
		return nil
	case schedule.FieldDay6:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay6(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schedule.FieldDay0) {
		fields = append(fields, schedule.FieldDay0)
	}
	if m.FieldCleared(schedule.FieldDay1) {
		fields = append(fields, schedule.FieldDay1)
	}
	if m.FieldCleared(schedule.FieldDay2) {
		fields = append(fields, schedule.FieldDay2)
	}
	if m.FieldCleared(schedule.FieldDay3) {
		fields = append(fields, schedule.FieldDay3)
	}
	if m.FieldCleared(schedule.FieldDay4) {
		fields = append(fields, schedule.FieldDay4)
	}
	if m.FieldCleared(schedule.FieldDay5) {
		fields = append(fields, schedule.FieldDay5)
	}
	if m.FieldCleared(schedule.FieldDay6) {
		fields = append(fields, schedule.FieldDay6)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	switch name {
	case schedule.FieldDay0:
		m.ClearDay0()
		return nil
	case schedule.FieldDay1:
		m.ClearDay1()
		return nil
	case schedule.FieldDay2:
		m.ClearDay2()
		return nil
	case schedule.FieldDay3:
		m.ClearDay3()
		return nil
	case schedule.FieldDay4:
		m.ClearDay4()
		return nil
	case schedule.FieldDay5:
		m.ClearDay5()
		return nil
	case schedule.FieldDay6:
		m.ClearDay6()
		return nil
	}
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldDay0:
		m.ResetDay0()
		return nil
	case schedule.FieldDay1:
		m.ResetDay1()
		return nil
	case schedule.FieldDay2:
		m.ResetDay2()
		return nil
	case schedule.FieldDay3:
		m.ResetDay3()
		return nil
	case schedule.FieldDay4:
		m.ResetDay4()
		return nil
	case schedule.FieldDay5:
		m.ResetDay5()
		return nil
	case schedule.FieldDay6:
		m.ResetDay6()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tutor != nil {
		edges = append(edges, schedule.EdgeTutor)
	}
	if m.class != nil {
		edges = append(edges, schedule.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	case schedule.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtutor {
		edges = append(edges, schedule.EdgeTutor)
	}
	if m.clearedclass {
		edges = append(edges, schedule.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case schedule.EdgeTutor:
		return m.clearedtutor
	case schedule.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	switch name {
	case schedule.EdgeTutor:
		m.ClearTutor()
		return nil
	case schedule.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	switch name {
	case schedule.EdgeTutor:
		m.ResetTutor()
		return nil
	case schedule.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	username            *string
	password            *string
	email               *string
	first_name          *string
	last_name           *string
	address             *string
	phone               *string
	birth_date          *time.Time
	gender              *string
	profile_picture_URL *string
	clearedFields       map[string]struct{}
	issue_report        map[uuid.UUID]struct{}
	removedissue_report map[uuid.UUID]struct{}
	clearedissue_report bool
	course              *uuid.UUID
	clearedcourse       bool
	class               *uuid.UUID
	clearedclass        bool
	done                bool
	oldValue            func(context.Context) (*Student, error)
	predicates          []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id uuid.UUID) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Student.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *StudentMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *StudentMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *StudentMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *StudentMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *StudentMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *StudentMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *StudentMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StudentMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *StudentMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *StudentMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *StudentMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *StudentMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *StudentMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *StudentMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *StudentMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddress sets the "address" field.
func (m *StudentMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *StudentMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *StudentMutation) ResetAddress() {
	m.address = nil
}

// SetPhone sets the "phone" field.
func (m *StudentMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *StudentMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *StudentMutation) ResetPhone() {
	m.phone = nil
}

// SetBirthDate sets the "birth_date" field.
func (m *StudentMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *StudentMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldBirthDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *StudentMutation) ResetBirthDate() {
	m.birth_date = nil
}

// SetGender sets the "gender" field.
func (m *StudentMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *StudentMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *StudentMutation) ResetGender() {
	m.gender = nil
}

// SetProfilePictureURL sets the "profile_picture_URL" field.
func (m *StudentMutation) SetProfilePictureURL(s string) {
	m.profile_picture_URL = &s
}

// ProfilePictureURL returns the value of the "profile_picture_URL" field in the mutation.
func (m *StudentMutation) ProfilePictureURL() (r string, exists bool) {
	v := m.profile_picture_URL
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureURL returns the old "profile_picture_URL" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldProfilePictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureURL: %w", err)
	}
	return oldValue.ProfilePictureURL, nil
}

// ClearProfilePictureURL clears the value of the "profile_picture_URL" field.
func (m *StudentMutation) ClearProfilePictureURL() {
	m.profile_picture_URL = nil
	m.clearedFields[student.FieldProfilePictureURL] = struct{}{}
}

// ProfilePictureURLCleared returns if the "profile_picture_URL" field was cleared in this mutation.
func (m *StudentMutation) ProfilePictureURLCleared() bool {
	_, ok := m.clearedFields[student.FieldProfilePictureURL]
	return ok
}

// ResetProfilePictureURL resets all changes to the "profile_picture_URL" field.
func (m *StudentMutation) ResetProfilePictureURL() {
	m.profile_picture_URL = nil
	delete(m.clearedFields, student.FieldProfilePictureURL)
}

// AddIssueReportIDs adds the "issue_report" edge to the IssueReport entity by ids.
func (m *StudentMutation) AddIssueReportIDs(ids ...uuid.UUID) {
	if m.issue_report == nil {
		m.issue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.issue_report[ids[i]] = struct{}{}
	}
}

// ClearIssueReport clears the "issue_report" edge to the IssueReport entity.
func (m *StudentMutation) ClearIssueReport() {
	m.clearedissue_report = true
}

// IssueReportCleared reports if the "issue_report" edge to the IssueReport entity was cleared.
func (m *StudentMutation) IssueReportCleared() bool {
	return m.clearedissue_report
}

// RemoveIssueReportIDs removes the "issue_report" edge to the IssueReport entity by IDs.
func (m *StudentMutation) RemoveIssueReportIDs(ids ...uuid.UUID) {
	if m.removedissue_report == nil {
		m.removedissue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.issue_report, ids[i])
		m.removedissue_report[ids[i]] = struct{}{}
	}
}

// RemovedIssueReport returns the removed IDs of the "issue_report" edge to the IssueReport entity.
func (m *StudentMutation) RemovedIssueReportIDs() (ids []uuid.UUID) {
	for id := range m.removedissue_report {
		ids = append(ids, id)
	}
	return
}

// IssueReportIDs returns the "issue_report" edge IDs in the mutation.
func (m *StudentMutation) IssueReportIDs() (ids []uuid.UUID) {
	for id := range m.issue_report {
		ids = append(ids, id)
	}
	return
}

// ResetIssueReport resets all changes to the "issue_report" edge.
func (m *StudentMutation) ResetIssueReport() {
	m.issue_report = nil
	m.clearedissue_report = false
	m.removedissue_report = nil
}

// SetCourseID sets the "course" edge to the Course entity by id.
func (m *StudentMutation) SetCourseID(id uuid.UUID) {
	m.course = &id
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *StudentMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *StudentMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the "course" edge ID in the mutation.
func (m *StudentMutation) CourseID() (id uuid.UUID, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *StudentMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *StudentMutation) SetClassID(id uuid.UUID) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *StudentMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *StudentMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *StudentMutation) ClassID() (id uuid.UUID, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) ClassIDs() (ids []uuid.UUID) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *StudentMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StudentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StudentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Student, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StudentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.username != nil {
		fields = append(fields, student.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, student.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, student.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, student.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, student.FieldLastName)
	}
	if m.address != nil {
		fields = append(fields, student.FieldAddress)
	}
	if m.phone != nil {
		fields = append(fields, student.FieldPhone)
	}
	if m.birth_date != nil {
		fields = append(fields, student.FieldBirthDate)
	}
	if m.gender != nil {
		fields = append(fields, student.FieldGender)
	}
	if m.profile_picture_URL != nil {
		fields = append(fields, student.FieldProfilePictureURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldUsername:
		return m.Username()
	case student.FieldPassword:
		return m.Password()
	case student.FieldEmail:
		return m.Email()
	case student.FieldFirstName:
		return m.FirstName()
	case student.FieldLastName:
		return m.LastName()
	case student.FieldAddress:
		return m.Address()
	case student.FieldPhone:
		return m.Phone()
	case student.FieldBirthDate:
		return m.BirthDate()
	case student.FieldGender:
		return m.Gender()
	case student.FieldProfilePictureURL:
		return m.ProfilePictureURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldUsername:
		return m.OldUsername(ctx)
	case student.FieldPassword:
		return m.OldPassword(ctx)
	case student.FieldEmail:
		return m.OldEmail(ctx)
	case student.FieldFirstName:
		return m.OldFirstName(ctx)
	case student.FieldLastName:
		return m.OldLastName(ctx)
	case student.FieldAddress:
		return m.OldAddress(ctx)
	case student.FieldPhone:
		return m.OldPhone(ctx)
	case student.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case student.FieldGender:
		return m.OldGender(ctx)
	case student.FieldProfilePictureURL:
		return m.OldProfilePictureURL(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case student.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case student.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case student.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case student.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case student.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case student.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case student.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case student.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case student.FieldProfilePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureURL(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(student.FieldProfilePictureURL) {
		fields = append(fields, student.FieldProfilePictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	switch name {
	case student.FieldProfilePictureURL:
		m.ClearProfilePictureURL()
		return nil
	}
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldUsername:
		m.ResetUsername()
		return nil
	case student.FieldPassword:
		m.ResetPassword()
		return nil
	case student.FieldEmail:
		m.ResetEmail()
		return nil
	case student.FieldFirstName:
		m.ResetFirstName()
		return nil
	case student.FieldLastName:
		m.ResetLastName()
		return nil
	case student.FieldAddress:
		m.ResetAddress()
		return nil
	case student.FieldPhone:
		m.ResetPhone()
		return nil
	case student.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case student.FieldGender:
		m.ResetGender()
		return nil
	case student.FieldProfilePictureURL:
		m.ResetProfilePictureURL()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.issue_report != nil {
		edges = append(edges, student.EdgeIssueReport)
	}
	if m.course != nil {
		edges = append(edges, student.EdgeCourse)
	}
	if m.class != nil {
		edges = append(edges, student.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.issue_report))
		for id := range m.issue_report {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedissue_report != nil {
		edges = append(edges, student.EdgeIssueReport)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.removedissue_report))
		for id := range m.removedissue_report {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedissue_report {
		edges = append(edges, student.EdgeIssueReport)
	}
	if m.clearedcourse {
		edges = append(edges, student.EdgeCourse)
	}
	if m.clearedclass {
		edges = append(edges, student.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeIssueReport:
		return m.clearedissue_report
	case student.EdgeCourse:
		return m.clearedcourse
	case student.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeCourse:
		m.ClearCourse()
		return nil
	case student.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeIssueReport:
		m.ResetIssueReport()
		return nil
	case student.EdgeCourse:
		m.ResetCourse()
		return nil
	case student.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// TutorMutation represents an operation that mutates the Tutor nodes in the graph.
type TutorMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	username            *string
	password            *string
	email               *string
	first_name          *string
	last_name           *string
	address             *string
	phone               *string
	birth_date          *time.Time
	gender              *string
	profile_picture_URL *string
	description         *string
	omise_bank_token    *string
	citizen_id          *string
	clearedFields       map[string]struct{}
	issue_report        map[uuid.UUID]struct{}
	removedissue_report map[uuid.UUID]struct{}
	clearedissue_report bool
	course              map[uuid.UUID]struct{}
	removedcourse       map[uuid.UUID]struct{}
	clearedcourse       bool
	review_tutor        map[int]struct{}
	removedreview_tutor map[int]struct{}
	clearedreview_tutor bool
	schedule            map[uuid.UUID]struct{}
	removedschedule     map[uuid.UUID]struct{}
	clearedschedule     bool
	done                bool
	oldValue            func(context.Context) (*Tutor, error)
	predicates          []predicate.Tutor
}

var _ ent.Mutation = (*TutorMutation)(nil)

// tutorOption allows management of the mutation configuration using functional options.
type tutorOption func(*TutorMutation)

// newTutorMutation creates new mutation for the Tutor entity.
func newTutorMutation(c config, op Op, opts ...tutorOption) *TutorMutation {
	m := &TutorMutation{
		config:        c,
		op:            op,
		typ:           TypeTutor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTutorID sets the ID field of the mutation.
func withTutorID(id uuid.UUID) tutorOption {
	return func(m *TutorMutation) {
		var (
			err   error
			once  sync.Once
			value *Tutor
		)
		m.oldValue = func(ctx context.Context) (*Tutor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tutor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTutor sets the old Tutor of the mutation.
func withTutor(node *Tutor) tutorOption {
	return func(m *TutorMutation) {
		m.oldValue = func(context.Context) (*Tutor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TutorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TutorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tutor entities.
func (m *TutorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TutorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TutorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tutor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *TutorMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *TutorMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *TutorMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *TutorMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *TutorMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *TutorMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *TutorMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TutorMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TutorMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *TutorMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *TutorMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *TutorMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *TutorMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *TutorMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *TutorMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddress sets the "address" field.
func (m *TutorMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *TutorMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *TutorMutation) ResetAddress() {
	m.address = nil
}

// SetPhone sets the "phone" field.
func (m *TutorMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *TutorMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *TutorMutation) ResetPhone() {
	m.phone = nil
}

// SetBirthDate sets the "birth_date" field.
func (m *TutorMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *TutorMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldBirthDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *TutorMutation) ResetBirthDate() {
	m.birth_date = nil
}

// SetGender sets the "gender" field.
func (m *TutorMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *TutorMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *TutorMutation) ResetGender() {
	m.gender = nil
}

// SetProfilePictureURL sets the "profile_picture_URL" field.
func (m *TutorMutation) SetProfilePictureURL(s string) {
	m.profile_picture_URL = &s
}

// ProfilePictureURL returns the value of the "profile_picture_URL" field in the mutation.
func (m *TutorMutation) ProfilePictureURL() (r string, exists bool) {
	v := m.profile_picture_URL
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureURL returns the old "profile_picture_URL" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldProfilePictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureURL: %w", err)
	}
	return oldValue.ProfilePictureURL, nil
}

// ClearProfilePictureURL clears the value of the "profile_picture_URL" field.
func (m *TutorMutation) ClearProfilePictureURL() {
	m.profile_picture_URL = nil
	m.clearedFields[tutor.FieldProfilePictureURL] = struct{}{}
}

// ProfilePictureURLCleared returns if the "profile_picture_URL" field was cleared in this mutation.
func (m *TutorMutation) ProfilePictureURLCleared() bool {
	_, ok := m.clearedFields[tutor.FieldProfilePictureURL]
	return ok
}

// ResetProfilePictureURL resets all changes to the "profile_picture_URL" field.
func (m *TutorMutation) ResetProfilePictureURL() {
	m.profile_picture_URL = nil
	delete(m.clearedFields, tutor.FieldProfilePictureURL)
}

// SetDescription sets the "description" field.
func (m *TutorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TutorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TutorMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tutor.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TutorMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tutor.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TutorMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tutor.FieldDescription)
}

// SetOmiseBankToken sets the "omise_bank_token" field.
func (m *TutorMutation) SetOmiseBankToken(s string) {
	m.omise_bank_token = &s
}

// OmiseBankToken returns the value of the "omise_bank_token" field in the mutation.
func (m *TutorMutation) OmiseBankToken() (r string, exists bool) {
	v := m.omise_bank_token
	if v == nil {
		return
	}
	return *v, true
}

// OldOmiseBankToken returns the old "omise_bank_token" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldOmiseBankToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOmiseBankToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOmiseBankToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOmiseBankToken: %w", err)
	}
	return oldValue.OmiseBankToken, nil
}

// ClearOmiseBankToken clears the value of the "omise_bank_token" field.
func (m *TutorMutation) ClearOmiseBankToken() {
	m.omise_bank_token = nil
	m.clearedFields[tutor.FieldOmiseBankToken] = struct{}{}
}

// OmiseBankTokenCleared returns if the "omise_bank_token" field was cleared in this mutation.
func (m *TutorMutation) OmiseBankTokenCleared() bool {
	_, ok := m.clearedFields[tutor.FieldOmiseBankToken]
	return ok
}

// ResetOmiseBankToken resets all changes to the "omise_bank_token" field.
func (m *TutorMutation) ResetOmiseBankToken() {
	m.omise_bank_token = nil
	delete(m.clearedFields, tutor.FieldOmiseBankToken)
}

// SetCitizenID sets the "citizen_id" field.
func (m *TutorMutation) SetCitizenID(s string) {
	m.citizen_id = &s
}

// CitizenID returns the value of the "citizen_id" field in the mutation.
func (m *TutorMutation) CitizenID() (r string, exists bool) {
	v := m.citizen_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCitizenID returns the old "citizen_id" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldCitizenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCitizenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCitizenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitizenID: %w", err)
	}
	return oldValue.CitizenID, nil
}

// ResetCitizenID resets all changes to the "citizen_id" field.
func (m *TutorMutation) ResetCitizenID() {
	m.citizen_id = nil
}

// AddIssueReportIDs adds the "issue_report" edge to the IssueReport entity by ids.
func (m *TutorMutation) AddIssueReportIDs(ids ...uuid.UUID) {
	if m.issue_report == nil {
		m.issue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.issue_report[ids[i]] = struct{}{}
	}
}

// ClearIssueReport clears the "issue_report" edge to the IssueReport entity.
func (m *TutorMutation) ClearIssueReport() {
	m.clearedissue_report = true
}

// IssueReportCleared reports if the "issue_report" edge to the IssueReport entity was cleared.
func (m *TutorMutation) IssueReportCleared() bool {
	return m.clearedissue_report
}

// RemoveIssueReportIDs removes the "issue_report" edge to the IssueReport entity by IDs.
func (m *TutorMutation) RemoveIssueReportIDs(ids ...uuid.UUID) {
	if m.removedissue_report == nil {
		m.removedissue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.issue_report, ids[i])
		m.removedissue_report[ids[i]] = struct{}{}
	}
}

// RemovedIssueReport returns the removed IDs of the "issue_report" edge to the IssueReport entity.
func (m *TutorMutation) RemovedIssueReportIDs() (ids []uuid.UUID) {
	for id := range m.removedissue_report {
		ids = append(ids, id)
	}
	return
}

// IssueReportIDs returns the "issue_report" edge IDs in the mutation.
func (m *TutorMutation) IssueReportIDs() (ids []uuid.UUID) {
	for id := range m.issue_report {
		ids = append(ids, id)
	}
	return
}

// ResetIssueReport resets all changes to the "issue_report" edge.
func (m *TutorMutation) ResetIssueReport() {
	m.issue_report = nil
	m.clearedissue_report = false
	m.removedissue_report = nil
}

// AddCourseIDs adds the "course" edge to the Course entity by ids.
func (m *TutorMutation) AddCourseIDs(ids ...uuid.UUID) {
	if m.course == nil {
		m.course = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *TutorMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *TutorMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the Course entity by IDs.
func (m *TutorMutation) RemoveCourseIDs(ids ...uuid.UUID) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course, ids[i])
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the Course entity.
func (m *TutorMutation) RemovedCourseIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *TutorMutation) CourseIDs() (ids []uuid.UUID) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *TutorMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// AddReviewTutorIDs adds the "review_tutor" edge to the ReviewTutor entity by ids.
func (m *TutorMutation) AddReviewTutorIDs(ids ...int) {
	if m.review_tutor == nil {
		m.review_tutor = make(map[int]struct{})
	}
	for i := range ids {
		m.review_tutor[ids[i]] = struct{}{}
	}
}

// ClearReviewTutor clears the "review_tutor" edge to the ReviewTutor entity.
func (m *TutorMutation) ClearReviewTutor() {
	m.clearedreview_tutor = true
}

// ReviewTutorCleared reports if the "review_tutor" edge to the ReviewTutor entity was cleared.
func (m *TutorMutation) ReviewTutorCleared() bool {
	return m.clearedreview_tutor
}

// RemoveReviewTutorIDs removes the "review_tutor" edge to the ReviewTutor entity by IDs.
func (m *TutorMutation) RemoveReviewTutorIDs(ids ...int) {
	if m.removedreview_tutor == nil {
		m.removedreview_tutor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.review_tutor, ids[i])
		m.removedreview_tutor[ids[i]] = struct{}{}
	}
}

// RemovedReviewTutor returns the removed IDs of the "review_tutor" edge to the ReviewTutor entity.
func (m *TutorMutation) RemovedReviewTutorIDs() (ids []int) {
	for id := range m.removedreview_tutor {
		ids = append(ids, id)
	}
	return
}

// ReviewTutorIDs returns the "review_tutor" edge IDs in the mutation.
func (m *TutorMutation) ReviewTutorIDs() (ids []int) {
	for id := range m.review_tutor {
		ids = append(ids, id)
	}
	return
}

// ResetReviewTutor resets all changes to the "review_tutor" edge.
func (m *TutorMutation) ResetReviewTutor() {
	m.review_tutor = nil
	m.clearedreview_tutor = false
	m.removedreview_tutor = nil
}

// AddScheduleIDs adds the "schedule" edge to the Schedule entity by ids.
func (m *TutorMutation) AddScheduleIDs(ids ...uuid.UUID) {
	if m.schedule == nil {
		m.schedule = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.schedule[ids[i]] = struct{}{}
	}
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *TutorMutation) ClearSchedule() {
	m.clearedschedule = true
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *TutorMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// RemoveScheduleIDs removes the "schedule" edge to the Schedule entity by IDs.
func (m *TutorMutation) RemoveScheduleIDs(ids ...uuid.UUID) {
	if m.removedschedule == nil {
		m.removedschedule = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.schedule, ids[i])
		m.removedschedule[ids[i]] = struct{}{}
	}
}

// RemovedSchedule returns the removed IDs of the "schedule" edge to the Schedule entity.
func (m *TutorMutation) RemovedScheduleIDs() (ids []uuid.UUID) {
	for id := range m.removedschedule {
		ids = append(ids, id)
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
func (m *TutorMutation) ScheduleIDs() (ids []uuid.UUID) {
	for id := range m.schedule {
		ids = append(ids, id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *TutorMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
	m.removedschedule = nil
}

// Where appends a list predicates to the TutorMutation builder.
func (m *TutorMutation) Where(ps ...predicate.Tutor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TutorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TutorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tutor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TutorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TutorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tutor).
func (m *TutorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TutorMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.username != nil {
		fields = append(fields, tutor.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, tutor.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, tutor.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, tutor.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, tutor.FieldLastName)
	}
	if m.address != nil {
		fields = append(fields, tutor.FieldAddress)
	}
	if m.phone != nil {
		fields = append(fields, tutor.FieldPhone)
	}
	if m.birth_date != nil {
		fields = append(fields, tutor.FieldBirthDate)
	}
	if m.gender != nil {
		fields = append(fields, tutor.FieldGender)
	}
	if m.profile_picture_URL != nil {
		fields = append(fields, tutor.FieldProfilePictureURL)
	}
	if m.description != nil {
		fields = append(fields, tutor.FieldDescription)
	}
	if m.omise_bank_token != nil {
		fields = append(fields, tutor.FieldOmiseBankToken)
	}
	if m.citizen_id != nil {
		fields = append(fields, tutor.FieldCitizenID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TutorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tutor.FieldUsername:
		return m.Username()
	case tutor.FieldPassword:
		return m.Password()
	case tutor.FieldEmail:
		return m.Email()
	case tutor.FieldFirstName:
		return m.FirstName()
	case tutor.FieldLastName:
		return m.LastName()
	case tutor.FieldAddress:
		return m.Address()
	case tutor.FieldPhone:
		return m.Phone()
	case tutor.FieldBirthDate:
		return m.BirthDate()
	case tutor.FieldGender:
		return m.Gender()
	case tutor.FieldProfilePictureURL:
		return m.ProfilePictureURL()
	case tutor.FieldDescription:
		return m.Description()
	case tutor.FieldOmiseBankToken:
		return m.OmiseBankToken()
	case tutor.FieldCitizenID:
		return m.CitizenID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TutorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tutor.FieldUsername:
		return m.OldUsername(ctx)
	case tutor.FieldPassword:
		return m.OldPassword(ctx)
	case tutor.FieldEmail:
		return m.OldEmail(ctx)
	case tutor.FieldFirstName:
		return m.OldFirstName(ctx)
	case tutor.FieldLastName:
		return m.OldLastName(ctx)
	case tutor.FieldAddress:
		return m.OldAddress(ctx)
	case tutor.FieldPhone:
		return m.OldPhone(ctx)
	case tutor.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case tutor.FieldGender:
		return m.OldGender(ctx)
	case tutor.FieldProfilePictureURL:
		return m.OldProfilePictureURL(ctx)
	case tutor.FieldDescription:
		return m.OldDescription(ctx)
	case tutor.FieldOmiseBankToken:
		return m.OldOmiseBankToken(ctx)
	case tutor.FieldCitizenID:
		return m.OldCitizenID(ctx)
	}
	return nil, fmt.Errorf("unknown Tutor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TutorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tutor.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case tutor.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case tutor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case tutor.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case tutor.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case tutor.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case tutor.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case tutor.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case tutor.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case tutor.FieldProfilePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureURL(v)
		return nil
	case tutor.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tutor.FieldOmiseBankToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOmiseBankToken(v)
		return nil
	case tutor.FieldCitizenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitizenID(v)
		return nil
	}
	return fmt.Errorf("unknown Tutor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TutorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TutorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TutorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tutor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TutorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tutor.FieldProfilePictureURL) {
		fields = append(fields, tutor.FieldProfilePictureURL)
	}
	if m.FieldCleared(tutor.FieldDescription) {
		fields = append(fields, tutor.FieldDescription)
	}
	if m.FieldCleared(tutor.FieldOmiseBankToken) {
		fields = append(fields, tutor.FieldOmiseBankToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TutorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TutorMutation) ClearField(name string) error {
	switch name {
	case tutor.FieldProfilePictureURL:
		m.ClearProfilePictureURL()
		return nil
	case tutor.FieldDescription:
		m.ClearDescription()
		return nil
	case tutor.FieldOmiseBankToken:
		m.ClearOmiseBankToken()
		return nil
	}
	return fmt.Errorf("unknown Tutor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TutorMutation) ResetField(name string) error {
	switch name {
	case tutor.FieldUsername:
		m.ResetUsername()
		return nil
	case tutor.FieldPassword:
		m.ResetPassword()
		return nil
	case tutor.FieldEmail:
		m.ResetEmail()
		return nil
	case tutor.FieldFirstName:
		m.ResetFirstName()
		return nil
	case tutor.FieldLastName:
		m.ResetLastName()
		return nil
	case tutor.FieldAddress:
		m.ResetAddress()
		return nil
	case tutor.FieldPhone:
		m.ResetPhone()
		return nil
	case tutor.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case tutor.FieldGender:
		m.ResetGender()
		return nil
	case tutor.FieldProfilePictureURL:
		m.ResetProfilePictureURL()
		return nil
	case tutor.FieldDescription:
		m.ResetDescription()
		return nil
	case tutor.FieldOmiseBankToken:
		m.ResetOmiseBankToken()
		return nil
	case tutor.FieldCitizenID:
		m.ResetCitizenID()
		return nil
	}
	return fmt.Errorf("unknown Tutor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TutorMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.issue_report != nil {
		edges = append(edges, tutor.EdgeIssueReport)
	}
	if m.course != nil {
		edges = append(edges, tutor.EdgeCourse)
	}
	if m.review_tutor != nil {
		edges = append(edges, tutor.EdgeReviewTutor)
	}
	if m.schedule != nil {
		edges = append(edges, tutor.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TutorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tutor.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.issue_report))
		for id := range m.issue_report {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeReviewTutor:
		ids := make([]ent.Value, 0, len(m.review_tutor))
		for id := range m.review_tutor {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeSchedule:
		ids := make([]ent.Value, 0, len(m.schedule))
		for id := range m.schedule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TutorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedissue_report != nil {
		edges = append(edges, tutor.EdgeIssueReport)
	}
	if m.removedcourse != nil {
		edges = append(edges, tutor.EdgeCourse)
	}
	if m.removedreview_tutor != nil {
		edges = append(edges, tutor.EdgeReviewTutor)
	}
	if m.removedschedule != nil {
		edges = append(edges, tutor.EdgeSchedule)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TutorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tutor.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.removedissue_report))
		for id := range m.removedissue_report {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeReviewTutor:
		ids := make([]ent.Value, 0, len(m.removedreview_tutor))
		for id := range m.removedreview_tutor {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeSchedule:
		ids := make([]ent.Value, 0, len(m.removedschedule))
		for id := range m.removedschedule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TutorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedissue_report {
		edges = append(edges, tutor.EdgeIssueReport)
	}
	if m.clearedcourse {
		edges = append(edges, tutor.EdgeCourse)
	}
	if m.clearedreview_tutor {
		edges = append(edges, tutor.EdgeReviewTutor)
	}
	if m.clearedschedule {
		edges = append(edges, tutor.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TutorMutation) EdgeCleared(name string) bool {
	switch name {
	case tutor.EdgeIssueReport:
		return m.clearedissue_report
	case tutor.EdgeCourse:
		return m.clearedcourse
	case tutor.EdgeReviewTutor:
		return m.clearedreview_tutor
	case tutor.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TutorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tutor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TutorMutation) ResetEdge(name string) error {
	switch name {
	case tutor.EdgeIssueReport:
		m.ResetIssueReport()
		return nil
	case tutor.EdgeCourse:
		m.ResetCourse()
		return nil
	case tutor.EdgeReviewTutor:
		m.ResetReviewTutor()
		return nil
	case tutor.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown Tutor edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	username            *string
	password            *string
	email               *string
	first_name          *string
	last_name           *string
	address             *string
	phone               *string
	birth_date          *time.Time
	gender              *string
	profile_picture_URL *string
	clearedFields       map[string]struct{}
	issue_report        map[uuid.UUID]struct{}
	removedissue_report map[uuid.UUID]struct{}
	clearedissue_report bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetBirthDate sets the "birth_date" field.
func (m *UserMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *UserMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *UserMutation) ResetBirthDate() {
	m.birth_date = nil
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
}

// SetProfilePictureURL sets the "profile_picture_URL" field.
func (m *UserMutation) SetProfilePictureURL(s string) {
	m.profile_picture_URL = &s
}

// ProfilePictureURL returns the value of the "profile_picture_URL" field in the mutation.
func (m *UserMutation) ProfilePictureURL() (r string, exists bool) {
	v := m.profile_picture_URL
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureURL returns the old "profile_picture_URL" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfilePictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureURL: %w", err)
	}
	return oldValue.ProfilePictureURL, nil
}

// ClearProfilePictureURL clears the value of the "profile_picture_URL" field.
func (m *UserMutation) ClearProfilePictureURL() {
	m.profile_picture_URL = nil
	m.clearedFields[user.FieldProfilePictureURL] = struct{}{}
}

// ProfilePictureURLCleared returns if the "profile_picture_URL" field was cleared in this mutation.
func (m *UserMutation) ProfilePictureURLCleared() bool {
	_, ok := m.clearedFields[user.FieldProfilePictureURL]
	return ok
}

// ResetProfilePictureURL resets all changes to the "profile_picture_URL" field.
func (m *UserMutation) ResetProfilePictureURL() {
	m.profile_picture_URL = nil
	delete(m.clearedFields, user.FieldProfilePictureURL)
}

// AddIssueReportIDs adds the "issue_report" edge to the IssueReport entity by ids.
func (m *UserMutation) AddIssueReportIDs(ids ...uuid.UUID) {
	if m.issue_report == nil {
		m.issue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.issue_report[ids[i]] = struct{}{}
	}
}

// ClearIssueReport clears the "issue_report" edge to the IssueReport entity.
func (m *UserMutation) ClearIssueReport() {
	m.clearedissue_report = true
}

// IssueReportCleared reports if the "issue_report" edge to the IssueReport entity was cleared.
func (m *UserMutation) IssueReportCleared() bool {
	return m.clearedissue_report
}

// RemoveIssueReportIDs removes the "issue_report" edge to the IssueReport entity by IDs.
func (m *UserMutation) RemoveIssueReportIDs(ids ...uuid.UUID) {
	if m.removedissue_report == nil {
		m.removedissue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.issue_report, ids[i])
		m.removedissue_report[ids[i]] = struct{}{}
	}
}

// RemovedIssueReport returns the removed IDs of the "issue_report" edge to the IssueReport entity.
func (m *UserMutation) RemovedIssueReportIDs() (ids []uuid.UUID) {
	for id := range m.removedissue_report {
		ids = append(ids, id)
	}
	return
}

// IssueReportIDs returns the "issue_report" edge IDs in the mutation.
func (m *UserMutation) IssueReportIDs() (ids []uuid.UUID) {
	for id := range m.issue_report {
		ids = append(ids, id)
	}
	return
}

// ResetIssueReport resets all changes to the "issue_report" edge.
func (m *UserMutation) ResetIssueReport() {
	m.issue_report = nil
	m.clearedissue_report = false
	m.removedissue_report = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.birth_date != nil {
		fields = append(fields, user.FieldBirthDate)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.profile_picture_URL != nil {
		fields = append(fields, user.FieldProfilePictureURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAddress:
		return m.Address()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldBirthDate:
		return m.BirthDate()
	case user.FieldGender:
		return m.Gender()
	case user.FieldProfilePictureURL:
		return m.ProfilePictureURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldProfilePictureURL:
		return m.OldProfilePictureURL(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case user.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldProfilePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureURL(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldProfilePictureURL) {
		fields = append(fields, user.FieldProfilePictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldProfilePictureURL:
		m.ClearProfilePictureURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldProfilePictureURL:
		m.ResetProfilePictureURL()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.issue_report != nil {
		edges = append(edges, user.EdgeIssueReport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.issue_report))
		for id := range m.issue_report {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedissue_report != nil {
		edges = append(edges, user.EdgeIssueReport)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.removedissue_report))
		for id := range m.removedissue_report {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedissue_report {
		edges = append(edges, user.EdgeIssueReport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeIssueReport:
		return m.clearedissue_report
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeIssueReport:
		m.ResetIssueReport()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
