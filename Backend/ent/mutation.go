// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/appointment"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/cancelrequest"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/course"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/issuereport"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/match"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/payment"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/paymenthistory"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/predicate"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/review"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/schedule"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/student"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/tutor"
	"github.com/2110336-2565-2/Sec3-Group16-Tuder/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppointment    = "Appointment"
	TypeCancelRequest  = "CancelRequest"
	TypeCourse         = "Course"
	TypeIssueReport    = "IssueReport"
	TypeMatch          = "Match"
	TypePayment        = "Payment"
	TypePaymentHistory = "PaymentHistory"
	TypeReview         = "Review"
	TypeSchedule       = "Schedule"
	TypeStudent        = "Student"
	TypeTutor          = "Tutor"
	TypeUser           = "User"
)

// AppointmentMutation represents an operation that mutates the Appointment nodes in the graph.
type AppointmentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	begin_at      *time.Time
	end_at        *time.Time
	status        *appointment.Status
	clearedFields map[string]struct{}
	match         *uuid.UUID
	clearedmatch  bool
	done          bool
	oldValue      func(context.Context) (*Appointment, error)
	predicates    []predicate.Appointment
}

var _ ent.Mutation = (*AppointmentMutation)(nil)

// appointmentOption allows management of the mutation configuration using functional options.
type appointmentOption func(*AppointmentMutation)

// newAppointmentMutation creates new mutation for the Appointment entity.
func newAppointmentMutation(c config, op Op, opts ...appointmentOption) *AppointmentMutation {
	m := &AppointmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAppointment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppointmentID sets the ID field of the mutation.
func withAppointmentID(id uuid.UUID) appointmentOption {
	return func(m *AppointmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Appointment
		)
		m.oldValue = func(ctx context.Context) (*Appointment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Appointment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppointment sets the old Appointment of the mutation.
func withAppointment(node *Appointment) appointmentOption {
	return func(m *AppointmentMutation) {
		m.oldValue = func(context.Context) (*Appointment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppointmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppointmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Appointment entities.
func (m *AppointmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppointmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppointmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Appointment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBeginAt sets the "begin_at" field.
func (m *AppointmentMutation) SetBeginAt(t time.Time) {
	m.begin_at = &t
}

// BeginAt returns the value of the "begin_at" field in the mutation.
func (m *AppointmentMutation) BeginAt() (r time.Time, exists bool) {
	v := m.begin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginAt returns the old "begin_at" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldBeginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginAt: %w", err)
	}
	return oldValue.BeginAt, nil
}

// ResetBeginAt resets all changes to the "begin_at" field.
func (m *AppointmentMutation) ResetBeginAt() {
	m.begin_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *AppointmentMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *AppointmentMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *AppointmentMutation) ResetEndAt() {
	m.end_at = nil
}

// SetStatus sets the "status" field.
func (m *AppointmentMutation) SetStatus(a appointment.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AppointmentMutation) Status() (r appointment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Appointment entity.
// If the Appointment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppointmentMutation) OldStatus(ctx context.Context) (v appointment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AppointmentMutation) ResetStatus() {
	m.status = nil
}

// SetMatchID sets the "match" edge to the Match entity by id.
func (m *AppointmentMutation) SetMatchID(id uuid.UUID) {
	m.match = &id
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *AppointmentMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *AppointmentMutation) MatchCleared() bool {
	return m.clearedmatch
}

// MatchID returns the "match" edge ID in the mutation.
func (m *AppointmentMutation) MatchID() (id uuid.UUID, exists bool) {
	if m.match != nil {
		return *m.match, true
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MatchID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) MatchIDs() (ids []uuid.UUID) {
	if id := m.match; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *AppointmentMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
}

// Where appends a list predicates to the AppointmentMutation builder.
func (m *AppointmentMutation) Where(ps ...predicate.Appointment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppointmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppointmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Appointment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppointmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppointmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Appointment).
func (m *AppointmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppointmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.begin_at != nil {
		fields = append(fields, appointment.FieldBeginAt)
	}
	if m.end_at != nil {
		fields = append(fields, appointment.FieldEndAt)
	}
	if m.status != nil {
		fields = append(fields, appointment.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppointmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldBeginAt:
		return m.BeginAt()
	case appointment.FieldEndAt:
		return m.EndAt()
	case appointment.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppointmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appointment.FieldBeginAt:
		return m.OldBeginAt(ctx)
	case appointment.FieldEndAt:
		return m.OldEndAt(ctx)
	case appointment.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Appointment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldBeginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginAt(v)
		return nil
	case appointment.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case appointment.FieldStatus:
		v, ok := value.(appointment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppointmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppointmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppointmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Appointment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppointmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppointmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppointmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Appointment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppointmentMutation) ResetField(name string) error {
	switch name {
	case appointment.FieldBeginAt:
		m.ResetBeginAt()
		return nil
	case appointment.FieldEndAt:
		m.ResetEndAt()
		return nil
	case appointment.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppointmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.match != nil {
		edges = append(edges, appointment.EdgeMatch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppointmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appointment.EdgeMatch:
		if id := m.match; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppointmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppointmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppointmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmatch {
		edges = append(edges, appointment.EdgeMatch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppointmentMutation) EdgeCleared(name string) bool {
	switch name {
	case appointment.EdgeMatch:
		return m.clearedmatch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppointmentMutation) ClearEdge(name string) error {
	switch name {
	case appointment.EdgeMatch:
		m.ClearMatch()
		return nil
	}
	return fmt.Errorf("unknown Appointment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppointmentMutation) ResetEdge(name string) error {
	switch name {
	case appointment.EdgeMatch:
		m.ResetMatch()
		return nil
	}
	return fmt.Errorf("unknown Appointment edge %s", name)
}

// CancelRequestMutation represents an operation that mutates the CancelRequest nodes in the graph.
type CancelRequestMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	title         *string
	report_date   *time.Time
	img_url       *string
	description   *string
	status        *cancelrequest.Status
	clearedFields map[string]struct{}
	match         *uuid.UUID
	clearedmatch  bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*CancelRequest, error)
	predicates    []predicate.CancelRequest
}

var _ ent.Mutation = (*CancelRequestMutation)(nil)

// cancelrequestOption allows management of the mutation configuration using functional options.
type cancelrequestOption func(*CancelRequestMutation)

// newCancelRequestMutation creates new mutation for the CancelRequest entity.
func newCancelRequestMutation(c config, op Op, opts ...cancelrequestOption) *CancelRequestMutation {
	m := &CancelRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeCancelRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCancelRequestID sets the ID field of the mutation.
func withCancelRequestID(id uuid.UUID) cancelrequestOption {
	return func(m *CancelRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *CancelRequest
		)
		m.oldValue = func(ctx context.Context) (*CancelRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CancelRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCancelRequest sets the old CancelRequest of the mutation.
func withCancelRequest(node *CancelRequest) cancelrequestOption {
	return func(m *CancelRequestMutation) {
		m.oldValue = func(context.Context) (*CancelRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CancelRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CancelRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CancelRequest entities.
func (m *CancelRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CancelRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CancelRequestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CancelRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *CancelRequestMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CancelRequestMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CancelRequest entity.
// If the CancelRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CancelRequestMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CancelRequestMutation) ResetTitle() {
	m.title = nil
}

// SetReportDate sets the "report_date" field.
func (m *CancelRequestMutation) SetReportDate(t time.Time) {
	m.report_date = &t
}

// ReportDate returns the value of the "report_date" field in the mutation.
func (m *CancelRequestMutation) ReportDate() (r time.Time, exists bool) {
	v := m.report_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReportDate returns the old "report_date" field's value of the CancelRequest entity.
// If the CancelRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CancelRequestMutation) OldReportDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportDate: %w", err)
	}
	return oldValue.ReportDate, nil
}

// ResetReportDate resets all changes to the "report_date" field.
func (m *CancelRequestMutation) ResetReportDate() {
	m.report_date = nil
}

// SetImgURL sets the "img_url" field.
func (m *CancelRequestMutation) SetImgURL(s string) {
	m.img_url = &s
}

// ImgURL returns the value of the "img_url" field in the mutation.
func (m *CancelRequestMutation) ImgURL() (r string, exists bool) {
	v := m.img_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImgURL returns the old "img_url" field's value of the CancelRequest entity.
// If the CancelRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CancelRequestMutation) OldImgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgURL: %w", err)
	}
	return oldValue.ImgURL, nil
}

// ResetImgURL resets all changes to the "img_url" field.
func (m *CancelRequestMutation) ResetImgURL() {
	m.img_url = nil
}

// SetDescription sets the "description" field.
func (m *CancelRequestMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CancelRequestMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CancelRequest entity.
// If the CancelRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CancelRequestMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CancelRequestMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *CancelRequestMutation) SetStatus(c cancelrequest.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CancelRequestMutation) Status() (r cancelrequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CancelRequest entity.
// If the CancelRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CancelRequestMutation) OldStatus(ctx context.Context) (v cancelrequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CancelRequestMutation) ResetStatus() {
	m.status = nil
}

// SetMatchID sets the "match" edge to the Match entity by id.
func (m *CancelRequestMutation) SetMatchID(id uuid.UUID) {
	m.match = &id
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *CancelRequestMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *CancelRequestMutation) MatchCleared() bool {
	return m.clearedmatch
}

// MatchID returns the "match" edge ID in the mutation.
func (m *CancelRequestMutation) MatchID() (id uuid.UUID, exists bool) {
	if m.match != nil {
		return *m.match, true
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MatchID instead. It exists only for internal usage by the builders.
func (m *CancelRequestMutation) MatchIDs() (ids []uuid.UUID) {
	if id := m.match; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *CancelRequestMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CancelRequestMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CancelRequestMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CancelRequestMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CancelRequestMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CancelRequestMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CancelRequestMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CancelRequestMutation builder.
func (m *CancelRequestMutation) Where(ps ...predicate.CancelRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CancelRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CancelRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CancelRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CancelRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CancelRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CancelRequest).
func (m *CancelRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CancelRequestMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.title != nil {
		fields = append(fields, cancelrequest.FieldTitle)
	}
	if m.report_date != nil {
		fields = append(fields, cancelrequest.FieldReportDate)
	}
	if m.img_url != nil {
		fields = append(fields, cancelrequest.FieldImgURL)
	}
	if m.description != nil {
		fields = append(fields, cancelrequest.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, cancelrequest.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CancelRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cancelrequest.FieldTitle:
		return m.Title()
	case cancelrequest.FieldReportDate:
		return m.ReportDate()
	case cancelrequest.FieldImgURL:
		return m.ImgURL()
	case cancelrequest.FieldDescription:
		return m.Description()
	case cancelrequest.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CancelRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cancelrequest.FieldTitle:
		return m.OldTitle(ctx)
	case cancelrequest.FieldReportDate:
		return m.OldReportDate(ctx)
	case cancelrequest.FieldImgURL:
		return m.OldImgURL(ctx)
	case cancelrequest.FieldDescription:
		return m.OldDescription(ctx)
	case cancelrequest.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CancelRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CancelRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cancelrequest.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case cancelrequest.FieldReportDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportDate(v)
		return nil
	case cancelrequest.FieldImgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgURL(v)
		return nil
	case cancelrequest.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case cancelrequest.FieldStatus:
		v, ok := value.(cancelrequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CancelRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CancelRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CancelRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CancelRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CancelRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CancelRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CancelRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CancelRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CancelRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CancelRequestMutation) ResetField(name string) error {
	switch name {
	case cancelrequest.FieldTitle:
		m.ResetTitle()
		return nil
	case cancelrequest.FieldReportDate:
		m.ResetReportDate()
		return nil
	case cancelrequest.FieldImgURL:
		m.ResetImgURL()
		return nil
	case cancelrequest.FieldDescription:
		m.ResetDescription()
		return nil
	case cancelrequest.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown CancelRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CancelRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.match != nil {
		edges = append(edges, cancelrequest.EdgeMatch)
	}
	if m.user != nil {
		edges = append(edges, cancelrequest.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CancelRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cancelrequest.EdgeMatch:
		if id := m.match; id != nil {
			return []ent.Value{*id}
		}
	case cancelrequest.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CancelRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CancelRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CancelRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmatch {
		edges = append(edges, cancelrequest.EdgeMatch)
	}
	if m.cleareduser {
		edges = append(edges, cancelrequest.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CancelRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case cancelrequest.EdgeMatch:
		return m.clearedmatch
	case cancelrequest.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CancelRequestMutation) ClearEdge(name string) error {
	switch name {
	case cancelrequest.EdgeMatch:
		m.ClearMatch()
		return nil
	case cancelrequest.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CancelRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CancelRequestMutation) ResetEdge(name string) error {
	switch name {
	case cancelrequest.EdgeMatch:
		m.ResetMatch()
		return nil
	case cancelrequest.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown CancelRequest edge %s", name)
}

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	title              *string
	subject            *string
	topic              *string
	estimated_time     *int
	addestimated_time  *int
	description        *string
	price_per_hour     *int
	addprice_per_hour  *int
	level              *course.Level
	course_picture_url *string
	clearedFields      map[string]struct{}
	review             map[uuid.UUID]struct{}
	removedreview      map[uuid.UUID]struct{}
	clearedreview      bool
	match              map[uuid.UUID]struct{}
	removedmatch       map[uuid.UUID]struct{}
	clearedmatch       bool
	tutor              *uuid.UUID
	clearedtutor       bool
	done               bool
	oldValue           func(context.Context) (*Course, error)
	predicates         []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id uuid.UUID) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Course entities.
func (m *CourseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *CourseMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CourseMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CourseMutation) ResetTitle() {
	m.title = nil
}

// SetSubject sets the "subject" field.
func (m *CourseMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *CourseMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *CourseMutation) ResetSubject() {
	m.subject = nil
}

// SetTopic sets the "topic" field.
func (m *CourseMutation) SetTopic(s string) {
	m.topic = &s
}

// Topic returns the value of the "topic" field in the mutation.
func (m *CourseMutation) Topic() (r string, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic returns the old "topic" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTopic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic: %w", err)
	}
	return oldValue.Topic, nil
}

// ResetTopic resets all changes to the "topic" field.
func (m *CourseMutation) ResetTopic() {
	m.topic = nil
}

// SetEstimatedTime sets the "estimated_time" field.
func (m *CourseMutation) SetEstimatedTime(i int) {
	m.estimated_time = &i
	m.addestimated_time = nil
}

// EstimatedTime returns the value of the "estimated_time" field in the mutation.
func (m *CourseMutation) EstimatedTime() (r int, exists bool) {
	v := m.estimated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedTime returns the old "estimated_time" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldEstimatedTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedTime: %w", err)
	}
	return oldValue.EstimatedTime, nil
}

// AddEstimatedTime adds i to the "estimated_time" field.
func (m *CourseMutation) AddEstimatedTime(i int) {
	if m.addestimated_time != nil {
		*m.addestimated_time += i
	} else {
		m.addestimated_time = &i
	}
}

// AddedEstimatedTime returns the value that was added to the "estimated_time" field in this mutation.
func (m *CourseMutation) AddedEstimatedTime() (r int, exists bool) {
	v := m.addestimated_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetEstimatedTime resets all changes to the "estimated_time" field.
func (m *CourseMutation) ResetEstimatedTime() {
	m.estimated_time = nil
	m.addestimated_time = nil
}

// SetDescription sets the "description" field.
func (m *CourseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CourseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CourseMutation) ResetDescription() {
	m.description = nil
}

// SetPricePerHour sets the "price_per_hour" field.
func (m *CourseMutation) SetPricePerHour(i int) {
	m.price_per_hour = &i
	m.addprice_per_hour = nil
}

// PricePerHour returns the value of the "price_per_hour" field in the mutation.
func (m *CourseMutation) PricePerHour() (r int, exists bool) {
	v := m.price_per_hour
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePerHour returns the old "price_per_hour" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldPricePerHour(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePerHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePerHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePerHour: %w", err)
	}
	return oldValue.PricePerHour, nil
}

// AddPricePerHour adds i to the "price_per_hour" field.
func (m *CourseMutation) AddPricePerHour(i int) {
	if m.addprice_per_hour != nil {
		*m.addprice_per_hour += i
	} else {
		m.addprice_per_hour = &i
	}
}

// AddedPricePerHour returns the value that was added to the "price_per_hour" field in this mutation.
func (m *CourseMutation) AddedPricePerHour() (r int, exists bool) {
	v := m.addprice_per_hour
	if v == nil {
		return
	}
	return *v, true
}

// ResetPricePerHour resets all changes to the "price_per_hour" field.
func (m *CourseMutation) ResetPricePerHour() {
	m.price_per_hour = nil
	m.addprice_per_hour = nil
}

// SetLevel sets the "level" field.
func (m *CourseMutation) SetLevel(c course.Level) {
	m.level = &c
}

// Level returns the value of the "level" field in the mutation.
func (m *CourseMutation) Level() (r course.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldLevel(ctx context.Context) (v course.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ClearLevel clears the value of the "level" field.
func (m *CourseMutation) ClearLevel() {
	m.level = nil
	m.clearedFields[course.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *CourseMutation) LevelCleared() bool {
	_, ok := m.clearedFields[course.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *CourseMutation) ResetLevel() {
	m.level = nil
	delete(m.clearedFields, course.FieldLevel)
}

// SetCoursePictureURL sets the "course_picture_url" field.
func (m *CourseMutation) SetCoursePictureURL(s string) {
	m.course_picture_url = &s
}

// CoursePictureURL returns the value of the "course_picture_url" field in the mutation.
func (m *CourseMutation) CoursePictureURL() (r string, exists bool) {
	v := m.course_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoursePictureURL returns the old "course_picture_url" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCoursePictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoursePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoursePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoursePictureURL: %w", err)
	}
	return oldValue.CoursePictureURL, nil
}

// ClearCoursePictureURL clears the value of the "course_picture_url" field.
func (m *CourseMutation) ClearCoursePictureURL() {
	m.course_picture_url = nil
	m.clearedFields[course.FieldCoursePictureURL] = struct{}{}
}

// CoursePictureURLCleared returns if the "course_picture_url" field was cleared in this mutation.
func (m *CourseMutation) CoursePictureURLCleared() bool {
	_, ok := m.clearedFields[course.FieldCoursePictureURL]
	return ok
}

// ResetCoursePictureURL resets all changes to the "course_picture_url" field.
func (m *CourseMutation) ResetCoursePictureURL() {
	m.course_picture_url = nil
	delete(m.clearedFields, course.FieldCoursePictureURL)
}

// AddReviewIDs adds the "review" edge to the Review entity by ids.
func (m *CourseMutation) AddReviewIDs(ids ...uuid.UUID) {
	if m.review == nil {
		m.review = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.review[ids[i]] = struct{}{}
	}
}

// ClearReview clears the "review" edge to the Review entity.
func (m *CourseMutation) ClearReview() {
	m.clearedreview = true
}

// ReviewCleared reports if the "review" edge to the Review entity was cleared.
func (m *CourseMutation) ReviewCleared() bool {
	return m.clearedreview
}

// RemoveReviewIDs removes the "review" edge to the Review entity by IDs.
func (m *CourseMutation) RemoveReviewIDs(ids ...uuid.UUID) {
	if m.removedreview == nil {
		m.removedreview = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.review, ids[i])
		m.removedreview[ids[i]] = struct{}{}
	}
}

// RemovedReview returns the removed IDs of the "review" edge to the Review entity.
func (m *CourseMutation) RemovedReviewIDs() (ids []uuid.UUID) {
	for id := range m.removedreview {
		ids = append(ids, id)
	}
	return
}

// ReviewIDs returns the "review" edge IDs in the mutation.
func (m *CourseMutation) ReviewIDs() (ids []uuid.UUID) {
	for id := range m.review {
		ids = append(ids, id)
	}
	return
}

// ResetReview resets all changes to the "review" edge.
func (m *CourseMutation) ResetReview() {
	m.review = nil
	m.clearedreview = false
	m.removedreview = nil
}

// AddMatchIDs adds the "match" edge to the Match entity by ids.
func (m *CourseMutation) AddMatchIDs(ids ...uuid.UUID) {
	if m.match == nil {
		m.match = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.match[ids[i]] = struct{}{}
	}
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *CourseMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *CourseMutation) MatchCleared() bool {
	return m.clearedmatch
}

// RemoveMatchIDs removes the "match" edge to the Match entity by IDs.
func (m *CourseMutation) RemoveMatchIDs(ids ...uuid.UUID) {
	if m.removedmatch == nil {
		m.removedmatch = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.match, ids[i])
		m.removedmatch[ids[i]] = struct{}{}
	}
}

// RemovedMatch returns the removed IDs of the "match" edge to the Match entity.
func (m *CourseMutation) RemovedMatchIDs() (ids []uuid.UUID) {
	for id := range m.removedmatch {
		ids = append(ids, id)
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
func (m *CourseMutation) MatchIDs() (ids []uuid.UUID) {
	for id := range m.match {
		ids = append(ids, id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *CourseMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
	m.removedmatch = nil
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *CourseMutation) SetTutorID(id uuid.UUID) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *CourseMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *CourseMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *CourseMutation) TutorID() (id uuid.UUID, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) TutorIDs() (ids []uuid.UUID) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *CourseMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, course.FieldTitle)
	}
	if m.subject != nil {
		fields = append(fields, course.FieldSubject)
	}
	if m.topic != nil {
		fields = append(fields, course.FieldTopic)
	}
	if m.estimated_time != nil {
		fields = append(fields, course.FieldEstimatedTime)
	}
	if m.description != nil {
		fields = append(fields, course.FieldDescription)
	}
	if m.price_per_hour != nil {
		fields = append(fields, course.FieldPricePerHour)
	}
	if m.level != nil {
		fields = append(fields, course.FieldLevel)
	}
	if m.course_picture_url != nil {
		fields = append(fields, course.FieldCoursePictureURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldTitle:
		return m.Title()
	case course.FieldSubject:
		return m.Subject()
	case course.FieldTopic:
		return m.Topic()
	case course.FieldEstimatedTime:
		return m.EstimatedTime()
	case course.FieldDescription:
		return m.Description()
	case course.FieldPricePerHour:
		return m.PricePerHour()
	case course.FieldLevel:
		return m.Level()
	case course.FieldCoursePictureURL:
		return m.CoursePictureURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldTitle:
		return m.OldTitle(ctx)
	case course.FieldSubject:
		return m.OldSubject(ctx)
	case course.FieldTopic:
		return m.OldTopic(ctx)
	case course.FieldEstimatedTime:
		return m.OldEstimatedTime(ctx)
	case course.FieldDescription:
		return m.OldDescription(ctx)
	case course.FieldPricePerHour:
		return m.OldPricePerHour(ctx)
	case course.FieldLevel:
		return m.OldLevel(ctx)
	case course.FieldCoursePictureURL:
		return m.OldCoursePictureURL(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case course.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case course.FieldTopic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic(v)
		return nil
	case course.FieldEstimatedTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedTime(v)
		return nil
	case course.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case course.FieldPricePerHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePerHour(v)
		return nil
	case course.FieldLevel:
		v, ok := value.(course.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case course.FieldCoursePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoursePictureURL(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	if m.addestimated_time != nil {
		fields = append(fields, course.FieldEstimatedTime)
	}
	if m.addprice_per_hour != nil {
		fields = append(fields, course.FieldPricePerHour)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case course.FieldEstimatedTime:
		return m.AddedEstimatedTime()
	case course.FieldPricePerHour:
		return m.AddedPricePerHour()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case course.FieldEstimatedTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedTime(v)
		return nil
	case course.FieldPricePerHour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPricePerHour(v)
		return nil
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(course.FieldLevel) {
		fields = append(fields, course.FieldLevel)
	}
	if m.FieldCleared(course.FieldCoursePictureURL) {
		fields = append(fields, course.FieldCoursePictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	switch name {
	case course.FieldLevel:
		m.ClearLevel()
		return nil
	case course.FieldCoursePictureURL:
		m.ClearCoursePictureURL()
		return nil
	}
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldTitle:
		m.ResetTitle()
		return nil
	case course.FieldSubject:
		m.ResetSubject()
		return nil
	case course.FieldTopic:
		m.ResetTopic()
		return nil
	case course.FieldEstimatedTime:
		m.ResetEstimatedTime()
		return nil
	case course.FieldDescription:
		m.ResetDescription()
		return nil
	case course.FieldPricePerHour:
		m.ResetPricePerHour()
		return nil
	case course.FieldLevel:
		m.ResetLevel()
		return nil
	case course.FieldCoursePictureURL:
		m.ResetCoursePictureURL()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.review != nil {
		edges = append(edges, course.EdgeReview)
	}
	if m.match != nil {
		edges = append(edges, course.EdgeMatch)
	}
	if m.tutor != nil {
		edges = append(edges, course.EdgeTutor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeReview:
		ids := make([]ent.Value, 0, len(m.review))
		for id := range m.review {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.match))
		for id := range m.match {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreview != nil {
		edges = append(edges, course.EdgeReview)
	}
	if m.removedmatch != nil {
		edges = append(edges, course.EdgeMatch)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeReview:
		ids := make([]ent.Value, 0, len(m.removedreview))
		for id := range m.removedreview {
			ids = append(ids, id)
		}
		return ids
	case course.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.removedmatch))
		for id := range m.removedmatch {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreview {
		edges = append(edges, course.EdgeReview)
	}
	if m.clearedmatch {
		edges = append(edges, course.EdgeMatch)
	}
	if m.clearedtutor {
		edges = append(edges, course.EdgeTutor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeReview:
		return m.clearedreview
	case course.EdgeMatch:
		return m.clearedmatch
	case course.EdgeTutor:
		return m.clearedtutor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeTutor:
		m.ClearTutor()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeReview:
		m.ResetReview()
		return nil
	case course.EdgeMatch:
		m.ResetMatch()
		return nil
	case course.EdgeTutor:
		m.ResetTutor()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// IssueReportMutation represents an operation that mutates the IssueReport nodes in the graph.
type IssueReportMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	title         *string
	description   *string
	contact       *string
	report_date   *time.Time
	status        *issuereport.Status
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IssueReport, error)
	predicates    []predicate.IssueReport
}

var _ ent.Mutation = (*IssueReportMutation)(nil)

// issuereportOption allows management of the mutation configuration using functional options.
type issuereportOption func(*IssueReportMutation)

// newIssueReportMutation creates new mutation for the IssueReport entity.
func newIssueReportMutation(c config, op Op, opts ...issuereportOption) *IssueReportMutation {
	m := &IssueReportMutation{
		config:        c,
		op:            op,
		typ:           TypeIssueReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssueReportID sets the ID field of the mutation.
func withIssueReportID(id uuid.UUID) issuereportOption {
	return func(m *IssueReportMutation) {
		var (
			err   error
			once  sync.Once
			value *IssueReport
		)
		m.oldValue = func(ctx context.Context) (*IssueReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IssueReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssueReport sets the old IssueReport of the mutation.
func withIssueReport(node *IssueReport) issuereportOption {
	return func(m *IssueReportMutation) {
		m.oldValue = func(context.Context) (*IssueReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssueReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssueReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IssueReport entities.
func (m *IssueReportMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssueReportMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssueReportMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IssueReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *IssueReportMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IssueReportMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IssueReportMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *IssueReportMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IssueReportMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *IssueReportMutation) ResetDescription() {
	m.description = nil
}

// SetContact sets the "contact" field.
func (m *IssueReportMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the value of the "contact" field in the mutation.
func (m *IssueReportMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ResetContact resets all changes to the "contact" field.
func (m *IssueReportMutation) ResetContact() {
	m.contact = nil
}

// SetReportDate sets the "report_date" field.
func (m *IssueReportMutation) SetReportDate(t time.Time) {
	m.report_date = &t
}

// ReportDate returns the value of the "report_date" field in the mutation.
func (m *IssueReportMutation) ReportDate() (r time.Time, exists bool) {
	v := m.report_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReportDate returns the old "report_date" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldReportDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportDate: %w", err)
	}
	return oldValue.ReportDate, nil
}

// ResetReportDate resets all changes to the "report_date" field.
func (m *IssueReportMutation) ResetReportDate() {
	m.report_date = nil
}

// SetStatus sets the "status" field.
func (m *IssueReportMutation) SetStatus(i issuereport.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *IssueReportMutation) Status() (r issuereport.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the IssueReport entity.
// If the IssueReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IssueReportMutation) OldStatus(ctx context.Context) (v issuereport.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IssueReportMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the IssueReportMutation builder.
func (m *IssueReportMutation) Where(ps ...predicate.IssueReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssueReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssueReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IssueReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssueReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssueReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IssueReport).
func (m *IssueReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssueReportMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.title != nil {
		fields = append(fields, issuereport.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, issuereport.FieldDescription)
	}
	if m.contact != nil {
		fields = append(fields, issuereport.FieldContact)
	}
	if m.report_date != nil {
		fields = append(fields, issuereport.FieldReportDate)
	}
	if m.status != nil {
		fields = append(fields, issuereport.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssueReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case issuereport.FieldTitle:
		return m.Title()
	case issuereport.FieldDescription:
		return m.Description()
	case issuereport.FieldContact:
		return m.Contact()
	case issuereport.FieldReportDate:
		return m.ReportDate()
	case issuereport.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssueReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case issuereport.FieldTitle:
		return m.OldTitle(ctx)
	case issuereport.FieldDescription:
		return m.OldDescription(ctx)
	case issuereport.FieldContact:
		return m.OldContact(ctx)
	case issuereport.FieldReportDate:
		return m.OldReportDate(ctx)
	case issuereport.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown IssueReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case issuereport.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case issuereport.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case issuereport.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case issuereport.FieldReportDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportDate(v)
		return nil
	case issuereport.FieldStatus:
		v, ok := value.(issuereport.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown IssueReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssueReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssueReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IssueReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssueReportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssueReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssueReportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IssueReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssueReportMutation) ResetField(name string) error {
	switch name {
	case issuereport.FieldTitle:
		m.ResetTitle()
		return nil
	case issuereport.FieldDescription:
		m.ResetDescription()
		return nil
	case issuereport.FieldContact:
		m.ResetContact()
		return nil
	case issuereport.FieldReportDate:
		m.ResetReportDate()
		return nil
	case issuereport.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown IssueReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssueReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssueReportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssueReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssueReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssueReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssueReportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssueReportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IssueReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssueReportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IssueReport edge %s", name)
}

// MatchMutation represents an operation that mutates the Match nodes in the graph.
type MatchMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	match_created_at      *time.Time
	clearedFields         map[string]struct{}
	student               *uuid.UUID
	clearedstudent        bool
	course                *uuid.UUID
	clearedcourse         bool
	appointment           map[uuid.UUID]struct{}
	removedappointment    map[uuid.UUID]struct{}
	clearedappointment    bool
	schedule              *uuid.UUID
	clearedschedule       bool
	cancel_request        map[uuid.UUID]struct{}
	removedcancel_request map[uuid.UUID]struct{}
	clearedcancel_request bool
	done                  bool
	oldValue              func(context.Context) (*Match, error)
	predicates            []predicate.Match
}

var _ ent.Mutation = (*MatchMutation)(nil)

// matchOption allows management of the mutation configuration using functional options.
type matchOption func(*MatchMutation)

// newMatchMutation creates new mutation for the Match entity.
func newMatchMutation(c config, op Op, opts ...matchOption) *MatchMutation {
	m := &MatchMutation{
		config:        c,
		op:            op,
		typ:           TypeMatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchID sets the ID field of the mutation.
func withMatchID(id uuid.UUID) matchOption {
	return func(m *MatchMutation) {
		var (
			err   error
			once  sync.Once
			value *Match
		)
		m.oldValue = func(ctx context.Context) (*Match, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Match.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatch sets the old Match of the mutation.
func withMatch(node *Match) matchOption {
	return func(m *MatchMutation) {
		m.oldValue = func(context.Context) (*Match, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Match entities.
func (m *MatchMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Match.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMatchCreatedAt sets the "match_created_at" field.
func (m *MatchMutation) SetMatchCreatedAt(t time.Time) {
	m.match_created_at = &t
}

// MatchCreatedAt returns the value of the "match_created_at" field in the mutation.
func (m *MatchMutation) MatchCreatedAt() (r time.Time, exists bool) {
	v := m.match_created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchCreatedAt returns the old "match_created_at" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldMatchCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchCreatedAt: %w", err)
	}
	return oldValue.MatchCreatedAt, nil
}

// ResetMatchCreatedAt resets all changes to the "match_created_at" field.
func (m *MatchMutation) ResetMatchCreatedAt() {
	m.match_created_at = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *MatchMutation) SetStudentID(id uuid.UUID) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *MatchMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *MatchMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *MatchMutation) StudentID() (id uuid.UUID, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *MatchMutation) StudentIDs() (ids []uuid.UUID) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *MatchMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetCourseID sets the "course" edge to the Course entity by id.
func (m *MatchMutation) SetCourseID(id uuid.UUID) {
	m.course = &id
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *MatchMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *MatchMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the "course" edge ID in the mutation.
func (m *MatchMutation) CourseID() (id uuid.UUID, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *MatchMutation) CourseIDs() (ids []uuid.UUID) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *MatchMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// AddAppointmentIDs adds the "appointment" edge to the Appointment entity by ids.
func (m *MatchMutation) AddAppointmentIDs(ids ...uuid.UUID) {
	if m.appointment == nil {
		m.appointment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.appointment[ids[i]] = struct{}{}
	}
}

// ClearAppointment clears the "appointment" edge to the Appointment entity.
func (m *MatchMutation) ClearAppointment() {
	m.clearedappointment = true
}

// AppointmentCleared reports if the "appointment" edge to the Appointment entity was cleared.
func (m *MatchMutation) AppointmentCleared() bool {
	return m.clearedappointment
}

// RemoveAppointmentIDs removes the "appointment" edge to the Appointment entity by IDs.
func (m *MatchMutation) RemoveAppointmentIDs(ids ...uuid.UUID) {
	if m.removedappointment == nil {
		m.removedappointment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.appointment, ids[i])
		m.removedappointment[ids[i]] = struct{}{}
	}
}

// RemovedAppointment returns the removed IDs of the "appointment" edge to the Appointment entity.
func (m *MatchMutation) RemovedAppointmentIDs() (ids []uuid.UUID) {
	for id := range m.removedappointment {
		ids = append(ids, id)
	}
	return
}

// AppointmentIDs returns the "appointment" edge IDs in the mutation.
func (m *MatchMutation) AppointmentIDs() (ids []uuid.UUID) {
	for id := range m.appointment {
		ids = append(ids, id)
	}
	return
}

// ResetAppointment resets all changes to the "appointment" edge.
func (m *MatchMutation) ResetAppointment() {
	m.appointment = nil
	m.clearedappointment = false
	m.removedappointment = nil
}

// SetScheduleID sets the "schedule" edge to the Schedule entity by id.
func (m *MatchMutation) SetScheduleID(id uuid.UUID) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *MatchMutation) ClearSchedule() {
	m.clearedschedule = true
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *MatchMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *MatchMutation) ScheduleID() (id uuid.UUID, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *MatchMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *MatchMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// AddCancelRequestIDs adds the "cancel_request" edge to the CancelRequest entity by ids.
func (m *MatchMutation) AddCancelRequestIDs(ids ...uuid.UUID) {
	if m.cancel_request == nil {
		m.cancel_request = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cancel_request[ids[i]] = struct{}{}
	}
}

// ClearCancelRequest clears the "cancel_request" edge to the CancelRequest entity.
func (m *MatchMutation) ClearCancelRequest() {
	m.clearedcancel_request = true
}

// CancelRequestCleared reports if the "cancel_request" edge to the CancelRequest entity was cleared.
func (m *MatchMutation) CancelRequestCleared() bool {
	return m.clearedcancel_request
}

// RemoveCancelRequestIDs removes the "cancel_request" edge to the CancelRequest entity by IDs.
func (m *MatchMutation) RemoveCancelRequestIDs(ids ...uuid.UUID) {
	if m.removedcancel_request == nil {
		m.removedcancel_request = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cancel_request, ids[i])
		m.removedcancel_request[ids[i]] = struct{}{}
	}
}

// RemovedCancelRequest returns the removed IDs of the "cancel_request" edge to the CancelRequest entity.
func (m *MatchMutation) RemovedCancelRequestIDs() (ids []uuid.UUID) {
	for id := range m.removedcancel_request {
		ids = append(ids, id)
	}
	return
}

// CancelRequestIDs returns the "cancel_request" edge IDs in the mutation.
func (m *MatchMutation) CancelRequestIDs() (ids []uuid.UUID) {
	for id := range m.cancel_request {
		ids = append(ids, id)
	}
	return
}

// ResetCancelRequest resets all changes to the "cancel_request" edge.
func (m *MatchMutation) ResetCancelRequest() {
	m.cancel_request = nil
	m.clearedcancel_request = false
	m.removedcancel_request = nil
}

// Where appends a list predicates to the MatchMutation builder.
func (m *MatchMutation) Where(ps ...predicate.Match) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Match, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Match).
func (m *MatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.match_created_at != nil {
		fields = append(fields, match.FieldMatchCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case match.FieldMatchCreatedAt:
		return m.MatchCreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case match.FieldMatchCreatedAt:
		return m.OldMatchCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Match field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case match.FieldMatchCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Match numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Match nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchMutation) ResetField(name string) error {
	switch name {
	case match.FieldMatchCreatedAt:
		m.ResetMatchCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.student != nil {
		edges = append(edges, match.EdgeStudent)
	}
	if m.course != nil {
		edges = append(edges, match.EdgeCourse)
	}
	if m.appointment != nil {
		edges = append(edges, match.EdgeAppointment)
	}
	if m.schedule != nil {
		edges = append(edges, match.EdgeSchedule)
	}
	if m.cancel_request != nil {
		edges = append(edges, match.EdgeCancelRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case match.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case match.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case match.EdgeAppointment:
		ids := make([]ent.Value, 0, len(m.appointment))
		for id := range m.appointment {
			ids = append(ids, id)
		}
		return ids
	case match.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	case match.EdgeCancelRequest:
		ids := make([]ent.Value, 0, len(m.cancel_request))
		for id := range m.cancel_request {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedappointment != nil {
		edges = append(edges, match.EdgeAppointment)
	}
	if m.removedcancel_request != nil {
		edges = append(edges, match.EdgeCancelRequest)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case match.EdgeAppointment:
		ids := make([]ent.Value, 0, len(m.removedappointment))
		for id := range m.removedappointment {
			ids = append(ids, id)
		}
		return ids
	case match.EdgeCancelRequest:
		ids := make([]ent.Value, 0, len(m.removedcancel_request))
		for id := range m.removedcancel_request {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedstudent {
		edges = append(edges, match.EdgeStudent)
	}
	if m.clearedcourse {
		edges = append(edges, match.EdgeCourse)
	}
	if m.clearedappointment {
		edges = append(edges, match.EdgeAppointment)
	}
	if m.clearedschedule {
		edges = append(edges, match.EdgeSchedule)
	}
	if m.clearedcancel_request {
		edges = append(edges, match.EdgeCancelRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchMutation) EdgeCleared(name string) bool {
	switch name {
	case match.EdgeStudent:
		return m.clearedstudent
	case match.EdgeCourse:
		return m.clearedcourse
	case match.EdgeAppointment:
		return m.clearedappointment
	case match.EdgeSchedule:
		return m.clearedschedule
	case match.EdgeCancelRequest:
		return m.clearedcancel_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchMutation) ClearEdge(name string) error {
	switch name {
	case match.EdgeStudent:
		m.ClearStudent()
		return nil
	case match.EdgeCourse:
		m.ClearCourse()
		return nil
	case match.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown Match unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchMutation) ResetEdge(name string) error {
	switch name {
	case match.EdgeStudent:
		m.ResetStudent()
		return nil
	case match.EdgeCourse:
		m.ResetCourse()
		return nil
	case match.EdgeAppointment:
		m.ResetAppointment()
		return nil
	case match.EdgeSchedule:
		m.ResetSchedule()
		return nil
	case match.EdgeCancelRequest:
		m.ResetCancelRequest()
		return nil
	}
	return fmt.Errorf("unknown Match edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	qr_picture_url         *string
	payment_status         *string
	card                   *string
	amount                 *int
	addamount              *int
	clearedFields          map[string]struct{}
	user                   *uuid.UUID
	cleareduser            bool
	payment_history        map[uuid.UUID]struct{}
	removedpayment_history map[uuid.UUID]struct{}
	clearedpayment_history bool
	done                   bool
	oldValue               func(context.Context) (*Payment, error)
	predicates             []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id uuid.UUID) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payment entities.
func (m *PaymentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQrPictureURL sets the "qr_picture_url" field.
func (m *PaymentMutation) SetQrPictureURL(s string) {
	m.qr_picture_url = &s
}

// QrPictureURL returns the value of the "qr_picture_url" field in the mutation.
func (m *PaymentMutation) QrPictureURL() (r string, exists bool) {
	v := m.qr_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldQrPictureURL returns the old "qr_picture_url" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldQrPictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrPictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrPictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrPictureURL: %w", err)
	}
	return oldValue.QrPictureURL, nil
}

// ClearQrPictureURL clears the value of the "qr_picture_url" field.
func (m *PaymentMutation) ClearQrPictureURL() {
	m.qr_picture_url = nil
	m.clearedFields[payment.FieldQrPictureURL] = struct{}{}
}

// QrPictureURLCleared returns if the "qr_picture_url" field was cleared in this mutation.
func (m *PaymentMutation) QrPictureURLCleared() bool {
	_, ok := m.clearedFields[payment.FieldQrPictureURL]
	return ok
}

// ResetQrPictureURL resets all changes to the "qr_picture_url" field.
func (m *PaymentMutation) ResetQrPictureURL() {
	m.qr_picture_url = nil
	delete(m.clearedFields, payment.FieldQrPictureURL)
}

// SetPaymentStatus sets the "payment_status" field.
func (m *PaymentMutation) SetPaymentStatus(s string) {
	m.payment_status = &s
}

// PaymentStatus returns the value of the "payment_status" field in the mutation.
func (m *PaymentMutation) PaymentStatus() (r string, exists bool) {
	v := m.payment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStatus returns the old "payment_status" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPaymentStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStatus: %w", err)
	}
	return oldValue.PaymentStatus, nil
}

// ResetPaymentStatus resets all changes to the "payment_status" field.
func (m *PaymentMutation) ResetPaymentStatus() {
	m.payment_status = nil
}

// SetCard sets the "card" field.
func (m *PaymentMutation) SetCard(s string) {
	m.card = &s
}

// Card returns the value of the "card" field in the mutation.
func (m *PaymentMutation) Card() (r string, exists bool) {
	v := m.card
	if v == nil {
		return
	}
	return *v, true
}

// OldCard returns the old "card" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCard: %w", err)
	}
	return oldValue.Card, nil
}

// ResetCard resets all changes to the "card" field.
func (m *PaymentMutation) ResetCard() {
	m.card = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *PaymentMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PaymentMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PaymentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PaymentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PaymentMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PaymentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddPaymentHistoryIDs adds the "payment_history" edge to the PaymentHistory entity by ids.
func (m *PaymentMutation) AddPaymentHistoryIDs(ids ...uuid.UUID) {
	if m.payment_history == nil {
		m.payment_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.payment_history[ids[i]] = struct{}{}
	}
}

// ClearPaymentHistory clears the "payment_history" edge to the PaymentHistory entity.
func (m *PaymentMutation) ClearPaymentHistory() {
	m.clearedpayment_history = true
}

// PaymentHistoryCleared reports if the "payment_history" edge to the PaymentHistory entity was cleared.
func (m *PaymentMutation) PaymentHistoryCleared() bool {
	return m.clearedpayment_history
}

// RemovePaymentHistoryIDs removes the "payment_history" edge to the PaymentHistory entity by IDs.
func (m *PaymentMutation) RemovePaymentHistoryIDs(ids ...uuid.UUID) {
	if m.removedpayment_history == nil {
		m.removedpayment_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.payment_history, ids[i])
		m.removedpayment_history[ids[i]] = struct{}{}
	}
}

// RemovedPaymentHistory returns the removed IDs of the "payment_history" edge to the PaymentHistory entity.
func (m *PaymentMutation) RemovedPaymentHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedpayment_history {
		ids = append(ids, id)
	}
	return
}

// PaymentHistoryIDs returns the "payment_history" edge IDs in the mutation.
func (m *PaymentMutation) PaymentHistoryIDs() (ids []uuid.UUID) {
	for id := range m.payment_history {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentHistory resets all changes to the "payment_history" edge.
func (m *PaymentMutation) ResetPaymentHistory() {
	m.payment_history = nil
	m.clearedpayment_history = false
	m.removedpayment_history = nil
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.qr_picture_url != nil {
		fields = append(fields, payment.FieldQrPictureURL)
	}
	if m.payment_status != nil {
		fields = append(fields, payment.FieldPaymentStatus)
	}
	if m.card != nil {
		fields = append(fields, payment.FieldCard)
	}
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldQrPictureURL:
		return m.QrPictureURL()
	case payment.FieldPaymentStatus:
		return m.PaymentStatus()
	case payment.FieldCard:
		return m.Card()
	case payment.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldQrPictureURL:
		return m.OldQrPictureURL(ctx)
	case payment.FieldPaymentStatus:
		return m.OldPaymentStatus(ctx)
	case payment.FieldCard:
		return m.OldCard(ctx)
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldQrPictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrPictureURL(v)
		return nil
	case payment.FieldPaymentStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStatus(v)
		return nil
	case payment.FieldCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCard(v)
		return nil
	case payment.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment.FieldQrPictureURL) {
		fields = append(fields, payment.FieldQrPictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	switch name {
	case payment.FieldQrPictureURL:
		m.ClearQrPictureURL()
		return nil
	}
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldQrPictureURL:
		m.ResetQrPictureURL()
		return nil
	case payment.FieldPaymentStatus:
		m.ResetPaymentStatus()
		return nil
	case payment.FieldCard:
		m.ResetCard()
		return nil
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, payment.EdgeUser)
	}
	if m.payment_history != nil {
		edges = append(edges, payment.EdgePaymentHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case payment.EdgePaymentHistory:
		ids := make([]ent.Value, 0, len(m.payment_history))
		for id := range m.payment_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpayment_history != nil {
		edges = append(edges, payment.EdgePaymentHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgePaymentHistory:
		ids := make([]ent.Value, 0, len(m.removedpayment_history))
		for id := range m.removedpayment_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, payment.EdgeUser)
	}
	if m.clearedpayment_history {
		edges = append(edges, payment.EdgePaymentHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeUser:
		return m.cleareduser
	case payment.EdgePaymentHistory:
		return m.clearedpayment_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeUser:
		m.ResetUser()
		return nil
	case payment.EdgePaymentHistory:
		m.ResetPaymentHistory()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PaymentHistoryMutation represents an operation that mutates the PaymentHistory nodes in the graph.
type PaymentHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	payment        *uuid.UUID
	clearedpayment bool
	done           bool
	oldValue       func(context.Context) (*PaymentHistory, error)
	predicates     []predicate.PaymentHistory
}

var _ ent.Mutation = (*PaymentHistoryMutation)(nil)

// paymenthistoryOption allows management of the mutation configuration using functional options.
type paymenthistoryOption func(*PaymentHistoryMutation)

// newPaymentHistoryMutation creates new mutation for the PaymentHistory entity.
func newPaymentHistoryMutation(c config, op Op, opts ...paymenthistoryOption) *PaymentHistoryMutation {
	m := &PaymentHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentHistoryID sets the ID field of the mutation.
func withPaymentHistoryID(id uuid.UUID) paymenthistoryOption {
	return func(m *PaymentHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentHistory
		)
		m.oldValue = func(ctx context.Context) (*PaymentHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentHistory sets the old PaymentHistory of the mutation.
func withPaymentHistory(node *PaymentHistory) paymenthistoryOption {
	return func(m *PaymentHistoryMutation) {
		m.oldValue = func(context.Context) (*PaymentHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentHistory entities.
func (m *PaymentHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PaymentHistoryMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PaymentHistoryMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PaymentHistoryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PaymentHistoryMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PaymentHistoryMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PaymentHistoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPaymentID sets the "payment" edge to the Payment entity by id.
func (m *PaymentHistoryMutation) SetPaymentID(id uuid.UUID) {
	m.payment = &id
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *PaymentHistoryMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *PaymentHistoryMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// PaymentID returns the "payment" edge ID in the mutation.
func (m *PaymentHistoryMutation) PaymentID() (id uuid.UUID, exists bool) {
	if m.payment != nil {
		return *m.payment, true
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentID instead. It exists only for internal usage by the builders.
func (m *PaymentHistoryMutation) PaymentIDs() (ids []uuid.UUID) {
	if id := m.payment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *PaymentHistoryMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
}

// Where appends a list predicates to the PaymentHistoryMutation builder.
func (m *PaymentHistoryMutation) Where(ps ...predicate.PaymentHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentHistory).
func (m *PaymentHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentHistoryMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentHistoryMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PaymentHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PaymentHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentHistoryMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PaymentHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaymentHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentHistoryMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PaymentHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, paymenthistory.EdgeUser)
	}
	if m.payment != nil {
		edges = append(edges, paymenthistory.EdgePayment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymenthistory.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case paymenthistory.EdgePayment:
		if id := m.payment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, paymenthistory.EdgeUser)
	}
	if m.clearedpayment {
		edges = append(edges, paymenthistory.EdgePayment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case paymenthistory.EdgeUser:
		return m.cleareduser
	case paymenthistory.EdgePayment:
		return m.clearedpayment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentHistoryMutation) ClearEdge(name string) error {
	switch name {
	case paymenthistory.EdgeUser:
		m.ClearUser()
		return nil
	case paymenthistory.EdgePayment:
		m.ClearPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentHistoryMutation) ResetEdge(name string) error {
	switch name {
	case paymenthistory.EdgeUser:
		m.ResetUser()
		return nil
	case paymenthistory.EdgePayment:
		m.ResetPayment()
		return nil
	}
	return fmt.Errorf("unknown PaymentHistory edge %s", name)
}

// ReviewMutation represents an operation that mutates the Review nodes in the graph.
type ReviewMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	score          *int8
	addscore       *int8
	review_msg     *string
	review_time_at *time.Time
	clearedFields  map[string]struct{}
	course         map[uuid.UUID]struct{}
	removedcourse  map[uuid.UUID]struct{}
	clearedcourse  bool
	student        map[uuid.UUID]struct{}
	removedstudent map[uuid.UUID]struct{}
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*Review, error)
	predicates     []predicate.Review
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows management of the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for the Review entity.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the ID field of the mutation.
func withReviewID(id uuid.UUID) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Review entities.
func (m *ReviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Review.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScore sets the "score" field.
func (m *ReviewMutation) SetScore(i int8) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ReviewMutation) Score() (r int8, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldScore(ctx context.Context) (v *int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *ReviewMutation) AddScore(i int8) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ReviewMutation) AddedScore() (r int8, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *ReviewMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[review.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ReviewMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[review.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ReviewMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, review.FieldScore)
}

// SetReviewMsg sets the "review_msg" field.
func (m *ReviewMutation) SetReviewMsg(s string) {
	m.review_msg = &s
}

// ReviewMsg returns the value of the "review_msg" field in the mutation.
func (m *ReviewMutation) ReviewMsg() (r string, exists bool) {
	v := m.review_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewMsg returns the old "review_msg" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldReviewMsg(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewMsg: %w", err)
	}
	return oldValue.ReviewMsg, nil
}

// ClearReviewMsg clears the value of the "review_msg" field.
func (m *ReviewMutation) ClearReviewMsg() {
	m.review_msg = nil
	m.clearedFields[review.FieldReviewMsg] = struct{}{}
}

// ReviewMsgCleared returns if the "review_msg" field was cleared in this mutation.
func (m *ReviewMutation) ReviewMsgCleared() bool {
	_, ok := m.clearedFields[review.FieldReviewMsg]
	return ok
}

// ResetReviewMsg resets all changes to the "review_msg" field.
func (m *ReviewMutation) ResetReviewMsg() {
	m.review_msg = nil
	delete(m.clearedFields, review.FieldReviewMsg)
}

// SetReviewTimeAt sets the "review_time_at" field.
func (m *ReviewMutation) SetReviewTimeAt(t time.Time) {
	m.review_time_at = &t
}

// ReviewTimeAt returns the value of the "review_time_at" field in the mutation.
func (m *ReviewMutation) ReviewTimeAt() (r time.Time, exists bool) {
	v := m.review_time_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewTimeAt returns the old "review_time_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldReviewTimeAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewTimeAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewTimeAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewTimeAt: %w", err)
	}
	return oldValue.ReviewTimeAt, nil
}

// ResetReviewTimeAt resets all changes to the "review_time_at" field.
func (m *ReviewMutation) ResetReviewTimeAt() {
	m.review_time_at = nil
}

// AddCourseIDs adds the "course" edge to the Course entity by ids.
func (m *ReviewMutation) AddCourseIDs(ids ...uuid.UUID) {
	if m.course == nil {
		m.course = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *ReviewMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *ReviewMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the Course entity by IDs.
func (m *ReviewMutation) RemoveCourseIDs(ids ...uuid.UUID) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course, ids[i])
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the Course entity.
func (m *ReviewMutation) RemovedCourseIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *ReviewMutation) CourseIDs() (ids []uuid.UUID) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ReviewMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// AddStudentIDs adds the "student" edge to the Student entity by ids.
func (m *ReviewMutation) AddStudentIDs(ids ...uuid.UUID) {
	if m.student == nil {
		m.student = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *ReviewMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *ReviewMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the Student entity by IDs.
func (m *ReviewMutation) RemoveStudentIDs(ids ...uuid.UUID) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the Student entity.
func (m *ReviewMutation) RemovedStudentIDs() (ids []uuid.UUID) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *ReviewMutation) StudentIDs() (ids []uuid.UUID) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ReviewMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// Where appends a list predicates to the ReviewMutation builder.
func (m *ReviewMutation) Where(ps ...predicate.Review) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Review, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.score != nil {
		fields = append(fields, review.FieldScore)
	}
	if m.review_msg != nil {
		fields = append(fields, review.FieldReviewMsg)
	}
	if m.review_time_at != nil {
		fields = append(fields, review.FieldReviewTimeAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldScore:
		return m.Score()
	case review.FieldReviewMsg:
		return m.ReviewMsg()
	case review.FieldReviewTimeAt:
		return m.ReviewTimeAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldScore:
		return m.OldScore(ctx)
	case review.FieldReviewMsg:
		return m.OldReviewMsg(ctx)
	case review.FieldReviewTimeAt:
		return m.OldReviewTimeAt(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldScore:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case review.FieldReviewMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewMsg(v)
		return nil
	case review.FieldReviewTimeAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewTimeAt(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, review.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case review.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case review.FieldScore:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(review.FieldScore) {
		fields = append(fields, review.FieldScore)
	}
	if m.FieldCleared(review.FieldReviewMsg) {
		fields = append(fields, review.FieldReviewMsg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	switch name {
	case review.FieldScore:
		m.ClearScore()
		return nil
	case review.FieldReviewMsg:
		m.ClearReviewMsg()
		return nil
	}
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldScore:
		m.ResetScore()
		return nil
	case review.FieldReviewMsg:
		m.ResetReviewMsg()
		return nil
	case review.FieldReviewTimeAt:
		m.ResetReviewTimeAt()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.course != nil {
		edges = append(edges, review.EdgeCourse)
	}
	if m.student != nil {
		edges = append(edges, review.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case review.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcourse != nil {
		edges = append(edges, review.EdgeCourse)
	}
	if m.removedstudent != nil {
		edges = append(edges, review.EdgeStudent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	case review.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcourse {
		edges = append(edges, review.EdgeCourse)
	}
	if m.clearedstudent {
		edges = append(edges, review.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case review.EdgeCourse:
		return m.clearedcourse
	case review.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	switch name {
	case review.EdgeCourse:
		m.ResetCourse()
		return nil
	case review.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown Review edge %s", name)
}

// ScheduleMutation represents an operation that mutates the Schedule nodes in the graph.
type ScheduleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	day_0         *[24]bool
	day_1         *[24]bool
	day_2         *[24]bool
	day_3         *[24]bool
	day_4         *[24]bool
	day_5         *[24]bool
	day_6         *[24]bool
	clearedFields map[string]struct{}
	tutor         *uuid.UUID
	clearedtutor  bool
	match         *uuid.UUID
	clearedmatch  bool
	done          bool
	oldValue      func(context.Context) (*Schedule, error)
	predicates    []predicate.Schedule
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows management of the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for the Schedule entity.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the ID field of the mutation.
func withScheduleID(id uuid.UUID) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Schedule entities.
func (m *ScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Schedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDay0 sets the "day_0" field.
func (m *ScheduleMutation) SetDay0(b [24]bool) {
	m.day_0 = &b
}

// Day0 returns the value of the "day_0" field in the mutation.
func (m *ScheduleMutation) Day0() (r [24]bool, exists bool) {
	v := m.day_0
	if v == nil {
		return
	}
	return *v, true
}

// OldDay0 returns the old "day_0" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay0(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay0 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay0 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay0: %w", err)
	}
	return oldValue.Day0, nil
}

// ResetDay0 resets all changes to the "day_0" field.
func (m *ScheduleMutation) ResetDay0() {
	m.day_0 = nil
}

// SetDay1 sets the "day_1" field.
func (m *ScheduleMutation) SetDay1(b [24]bool) {
	m.day_1 = &b
}

// Day1 returns the value of the "day_1" field in the mutation.
func (m *ScheduleMutation) Day1() (r [24]bool, exists bool) {
	v := m.day_1
	if v == nil {
		return
	}
	return *v, true
}

// OldDay1 returns the old "day_1" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay1(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay1: %w", err)
	}
	return oldValue.Day1, nil
}

// ResetDay1 resets all changes to the "day_1" field.
func (m *ScheduleMutation) ResetDay1() {
	m.day_1 = nil
}

// SetDay2 sets the "day_2" field.
func (m *ScheduleMutation) SetDay2(b [24]bool) {
	m.day_2 = &b
}

// Day2 returns the value of the "day_2" field in the mutation.
func (m *ScheduleMutation) Day2() (r [24]bool, exists bool) {
	v := m.day_2
	if v == nil {
		return
	}
	return *v, true
}

// OldDay2 returns the old "day_2" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay2(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay2: %w", err)
	}
	return oldValue.Day2, nil
}

// ResetDay2 resets all changes to the "day_2" field.
func (m *ScheduleMutation) ResetDay2() {
	m.day_2 = nil
}

// SetDay3 sets the "day_3" field.
func (m *ScheduleMutation) SetDay3(b [24]bool) {
	m.day_3 = &b
}

// Day3 returns the value of the "day_3" field in the mutation.
func (m *ScheduleMutation) Day3() (r [24]bool, exists bool) {
	v := m.day_3
	if v == nil {
		return
	}
	return *v, true
}

// OldDay3 returns the old "day_3" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay3(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay3: %w", err)
	}
	return oldValue.Day3, nil
}

// ResetDay3 resets all changes to the "day_3" field.
func (m *ScheduleMutation) ResetDay3() {
	m.day_3 = nil
}

// SetDay4 sets the "day_4" field.
func (m *ScheduleMutation) SetDay4(b [24]bool) {
	m.day_4 = &b
}

// Day4 returns the value of the "day_4" field in the mutation.
func (m *ScheduleMutation) Day4() (r [24]bool, exists bool) {
	v := m.day_4
	if v == nil {
		return
	}
	return *v, true
}

// OldDay4 returns the old "day_4" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay4(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay4: %w", err)
	}
	return oldValue.Day4, nil
}

// ResetDay4 resets all changes to the "day_4" field.
func (m *ScheduleMutation) ResetDay4() {
	m.day_4 = nil
}

// SetDay5 sets the "day_5" field.
func (m *ScheduleMutation) SetDay5(b [24]bool) {
	m.day_5 = &b
}

// Day5 returns the value of the "day_5" field in the mutation.
func (m *ScheduleMutation) Day5() (r [24]bool, exists bool) {
	v := m.day_5
	if v == nil {
		return
	}
	return *v, true
}

// OldDay5 returns the old "day_5" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay5(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay5: %w", err)
	}
	return oldValue.Day5, nil
}

// ResetDay5 resets all changes to the "day_5" field.
func (m *ScheduleMutation) ResetDay5() {
	m.day_5 = nil
}

// SetDay6 sets the "day_6" field.
func (m *ScheduleMutation) SetDay6(b [24]bool) {
	m.day_6 = &b
}

// Day6 returns the value of the "day_6" field in the mutation.
func (m *ScheduleMutation) Day6() (r [24]bool, exists bool) {
	v := m.day_6
	if v == nil {
		return
	}
	return *v, true
}

// OldDay6 returns the old "day_6" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDay6(ctx context.Context) (v [24]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDay6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDay6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDay6: %w", err)
	}
	return oldValue.Day6, nil
}

// ResetDay6 resets all changes to the "day_6" field.
func (m *ScheduleMutation) ResetDay6() {
	m.day_6 = nil
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *ScheduleMutation) SetTutorID(id uuid.UUID) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *ScheduleMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *ScheduleMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *ScheduleMutation) TutorID() (id uuid.UUID, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) TutorIDs() (ids []uuid.UUID) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *ScheduleMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// SetMatchID sets the "match" edge to the Match entity by id.
func (m *ScheduleMutation) SetMatchID(id uuid.UUID) {
	m.match = &id
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *ScheduleMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *ScheduleMutation) MatchCleared() bool {
	return m.clearedmatch
}

// MatchID returns the "match" edge ID in the mutation.
func (m *ScheduleMutation) MatchID() (id uuid.UUID, exists bool) {
	if m.match != nil {
		return *m.match, true
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MatchID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) MatchIDs() (ids []uuid.UUID) {
	if id := m.match; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *ScheduleMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
}

// Where appends a list predicates to the ScheduleMutation builder.
func (m *ScheduleMutation) Where(ps ...predicate.Schedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Schedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.day_0 != nil {
		fields = append(fields, schedule.FieldDay0)
	}
	if m.day_1 != nil {
		fields = append(fields, schedule.FieldDay1)
	}
	if m.day_2 != nil {
		fields = append(fields, schedule.FieldDay2)
	}
	if m.day_3 != nil {
		fields = append(fields, schedule.FieldDay3)
	}
	if m.day_4 != nil {
		fields = append(fields, schedule.FieldDay4)
	}
	if m.day_5 != nil {
		fields = append(fields, schedule.FieldDay5)
	}
	if m.day_6 != nil {
		fields = append(fields, schedule.FieldDay6)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldDay0:
		return m.Day0()
	case schedule.FieldDay1:
		return m.Day1()
	case schedule.FieldDay2:
		return m.Day2()
	case schedule.FieldDay3:
		return m.Day3()
	case schedule.FieldDay4:
		return m.Day4()
	case schedule.FieldDay5:
		return m.Day5()
	case schedule.FieldDay6:
		return m.Day6()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldDay0:
		return m.OldDay0(ctx)
	case schedule.FieldDay1:
		return m.OldDay1(ctx)
	case schedule.FieldDay2:
		return m.OldDay2(ctx)
	case schedule.FieldDay3:
		return m.OldDay3(ctx)
	case schedule.FieldDay4:
		return m.OldDay4(ctx)
	case schedule.FieldDay5:
		return m.OldDay5(ctx)
	case schedule.FieldDay6:
		return m.OldDay6(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldDay0:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay0(v)
		return nil
	case schedule.FieldDay1:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay1(v)
		return nil
	case schedule.FieldDay2:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay2(v)
		return nil
	case schedule.FieldDay3:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay3(v)
		return nil
	case schedule.FieldDay4:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay4(v)
		return nil
	case schedule.FieldDay5:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay5(v)
		return nil
	case schedule.FieldDay6:
		v, ok := value.([24]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDay6(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldDay0:
		m.ResetDay0()
		return nil
	case schedule.FieldDay1:
		m.ResetDay1()
		return nil
	case schedule.FieldDay2:
		m.ResetDay2()
		return nil
	case schedule.FieldDay3:
		m.ResetDay3()
		return nil
	case schedule.FieldDay4:
		m.ResetDay4()
		return nil
	case schedule.FieldDay5:
		m.ResetDay5()
		return nil
	case schedule.FieldDay6:
		m.ResetDay6()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tutor != nil {
		edges = append(edges, schedule.EdgeTutor)
	}
	if m.match != nil {
		edges = append(edges, schedule.EdgeMatch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	case schedule.EdgeMatch:
		if id := m.match; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtutor {
		edges = append(edges, schedule.EdgeTutor)
	}
	if m.clearedmatch {
		edges = append(edges, schedule.EdgeMatch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case schedule.EdgeTutor:
		return m.clearedtutor
	case schedule.EdgeMatch:
		return m.clearedmatch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	switch name {
	case schedule.EdgeTutor:
		m.ClearTutor()
		return nil
	case schedule.EdgeMatch:
		m.ClearMatch()
		return nil
	}
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	switch name {
	case schedule.EdgeTutor:
		m.ResetTutor()
		return nil
	case schedule.EdgeMatch:
		m.ResetMatch()
		return nil
	}
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	match         map[uuid.UUID]struct{}
	removedmatch  map[uuid.UUID]struct{}
	clearedmatch  bool
	review        map[uuid.UUID]struct{}
	removedreview map[uuid.UUID]struct{}
	clearedreview bool
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Student, error)
	predicates    []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id uuid.UUID) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Student.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddMatchIDs adds the "match" edge to the Match entity by ids.
func (m *StudentMutation) AddMatchIDs(ids ...uuid.UUID) {
	if m.match == nil {
		m.match = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.match[ids[i]] = struct{}{}
	}
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *StudentMutation) ClearMatch() {
	m.clearedmatch = true
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *StudentMutation) MatchCleared() bool {
	return m.clearedmatch
}

// RemoveMatchIDs removes the "match" edge to the Match entity by IDs.
func (m *StudentMutation) RemoveMatchIDs(ids ...uuid.UUID) {
	if m.removedmatch == nil {
		m.removedmatch = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.match, ids[i])
		m.removedmatch[ids[i]] = struct{}{}
	}
}

// RemovedMatch returns the removed IDs of the "match" edge to the Match entity.
func (m *StudentMutation) RemovedMatchIDs() (ids []uuid.UUID) {
	for id := range m.removedmatch {
		ids = append(ids, id)
	}
	return
}

// MatchIDs returns the "match" edge IDs in the mutation.
func (m *StudentMutation) MatchIDs() (ids []uuid.UUID) {
	for id := range m.match {
		ids = append(ids, id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *StudentMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
	m.removedmatch = nil
}

// AddReviewIDs adds the "review" edge to the Review entity by ids.
func (m *StudentMutation) AddReviewIDs(ids ...uuid.UUID) {
	if m.review == nil {
		m.review = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.review[ids[i]] = struct{}{}
	}
}

// ClearReview clears the "review" edge to the Review entity.
func (m *StudentMutation) ClearReview() {
	m.clearedreview = true
}

// ReviewCleared reports if the "review" edge to the Review entity was cleared.
func (m *StudentMutation) ReviewCleared() bool {
	return m.clearedreview
}

// RemoveReviewIDs removes the "review" edge to the Review entity by IDs.
func (m *StudentMutation) RemoveReviewIDs(ids ...uuid.UUID) {
	if m.removedreview == nil {
		m.removedreview = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.review, ids[i])
		m.removedreview[ids[i]] = struct{}{}
	}
}

// RemovedReview returns the removed IDs of the "review" edge to the Review entity.
func (m *StudentMutation) RemovedReviewIDs() (ids []uuid.UUID) {
	for id := range m.removedreview {
		ids = append(ids, id)
	}
	return
}

// ReviewIDs returns the "review" edge IDs in the mutation.
func (m *StudentMutation) ReviewIDs() (ids []uuid.UUID) {
	for id := range m.review {
		ids = append(ids, id)
	}
	return
}

// ResetReview resets all changes to the "review" edge.
func (m *StudentMutation) ResetReview() {
	m.review = nil
	m.clearedreview = false
	m.removedreview = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StudentMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StudentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StudentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StudentMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StudentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StudentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StudentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Student, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StudentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.match != nil {
		edges = append(edges, student.EdgeMatch)
	}
	if m.review != nil {
		edges = append(edges, student.EdgeReview)
	}
	if m.user != nil {
		edges = append(edges, student.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.match))
		for id := range m.match {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeReview:
		ids := make([]ent.Value, 0, len(m.review))
		for id := range m.review {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmatch != nil {
		edges = append(edges, student.EdgeMatch)
	}
	if m.removedreview != nil {
		edges = append(edges, student.EdgeReview)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeMatch:
		ids := make([]ent.Value, 0, len(m.removedmatch))
		for id := range m.removedmatch {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeReview:
		ids := make([]ent.Value, 0, len(m.removedreview))
		for id := range m.removedreview {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmatch {
		edges = append(edges, student.EdgeMatch)
	}
	if m.clearedreview {
		edges = append(edges, student.EdgeReview)
	}
	if m.cleareduser {
		edges = append(edges, student.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeMatch:
		return m.clearedmatch
	case student.EdgeReview:
		return m.clearedreview
	case student.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeMatch:
		m.ResetMatch()
		return nil
	case student.EdgeReview:
		m.ResetReview()
		return nil
	case student.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// TutorMutation represents an operation that mutates the Tutor nodes in the graph.
type TutorMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	description         *string
	omise_bank_token    *string
	citizen_id          *string
	omise_customer_id   *string
	clearedFields       map[string]struct{}
	issue_report        map[uuid.UUID]struct{}
	removedissue_report map[uuid.UUID]struct{}
	clearedissue_report bool
	course              map[uuid.UUID]struct{}
	removedcourse       map[uuid.UUID]struct{}
	clearedcourse       bool
	user                *uuid.UUID
	cleareduser         bool
	schedule            *uuid.UUID
	clearedschedule     bool
	done                bool
	oldValue            func(context.Context) (*Tutor, error)
	predicates          []predicate.Tutor
}

var _ ent.Mutation = (*TutorMutation)(nil)

// tutorOption allows management of the mutation configuration using functional options.
type tutorOption func(*TutorMutation)

// newTutorMutation creates new mutation for the Tutor entity.
func newTutorMutation(c config, op Op, opts ...tutorOption) *TutorMutation {
	m := &TutorMutation{
		config:        c,
		op:            op,
		typ:           TypeTutor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTutorID sets the ID field of the mutation.
func withTutorID(id uuid.UUID) tutorOption {
	return func(m *TutorMutation) {
		var (
			err   error
			once  sync.Once
			value *Tutor
		)
		m.oldValue = func(ctx context.Context) (*Tutor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tutor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTutor sets the old Tutor of the mutation.
func withTutor(node *Tutor) tutorOption {
	return func(m *TutorMutation) {
		m.oldValue = func(context.Context) (*Tutor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TutorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TutorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tutor entities.
func (m *TutorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TutorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TutorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tutor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *TutorMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TutorMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TutorMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tutor.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TutorMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tutor.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TutorMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tutor.FieldDescription)
}

// SetOmiseBankToken sets the "omise_bank_token" field.
func (m *TutorMutation) SetOmiseBankToken(s string) {
	m.omise_bank_token = &s
}

// OmiseBankToken returns the value of the "omise_bank_token" field in the mutation.
func (m *TutorMutation) OmiseBankToken() (r string, exists bool) {
	v := m.omise_bank_token
	if v == nil {
		return
	}
	return *v, true
}

// OldOmiseBankToken returns the old "omise_bank_token" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldOmiseBankToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOmiseBankToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOmiseBankToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOmiseBankToken: %w", err)
	}
	return oldValue.OmiseBankToken, nil
}

// ClearOmiseBankToken clears the value of the "omise_bank_token" field.
func (m *TutorMutation) ClearOmiseBankToken() {
	m.omise_bank_token = nil
	m.clearedFields[tutor.FieldOmiseBankToken] = struct{}{}
}

// OmiseBankTokenCleared returns if the "omise_bank_token" field was cleared in this mutation.
func (m *TutorMutation) OmiseBankTokenCleared() bool {
	_, ok := m.clearedFields[tutor.FieldOmiseBankToken]
	return ok
}

// ResetOmiseBankToken resets all changes to the "omise_bank_token" field.
func (m *TutorMutation) ResetOmiseBankToken() {
	m.omise_bank_token = nil
	delete(m.clearedFields, tutor.FieldOmiseBankToken)
}

// SetCitizenID sets the "citizen_id" field.
func (m *TutorMutation) SetCitizenID(s string) {
	m.citizen_id = &s
}

// CitizenID returns the value of the "citizen_id" field in the mutation.
func (m *TutorMutation) CitizenID() (r string, exists bool) {
	v := m.citizen_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCitizenID returns the old "citizen_id" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldCitizenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCitizenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCitizenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitizenID: %w", err)
	}
	return oldValue.CitizenID, nil
}

// ResetCitizenID resets all changes to the "citizen_id" field.
func (m *TutorMutation) ResetCitizenID() {
	m.citizen_id = nil
}

// SetOmiseCustomerID sets the "omise_customer_id" field.
func (m *TutorMutation) SetOmiseCustomerID(s string) {
	m.omise_customer_id = &s
}

// OmiseCustomerID returns the value of the "omise_customer_id" field in the mutation.
func (m *TutorMutation) OmiseCustomerID() (r string, exists bool) {
	v := m.omise_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOmiseCustomerID returns the old "omise_customer_id" field's value of the Tutor entity.
// If the Tutor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TutorMutation) OldOmiseCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOmiseCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOmiseCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOmiseCustomerID: %w", err)
	}
	return oldValue.OmiseCustomerID, nil
}

// ClearOmiseCustomerID clears the value of the "omise_customer_id" field.
func (m *TutorMutation) ClearOmiseCustomerID() {
	m.omise_customer_id = nil
	m.clearedFields[tutor.FieldOmiseCustomerID] = struct{}{}
}

// OmiseCustomerIDCleared returns if the "omise_customer_id" field was cleared in this mutation.
func (m *TutorMutation) OmiseCustomerIDCleared() bool {
	_, ok := m.clearedFields[tutor.FieldOmiseCustomerID]
	return ok
}

// ResetOmiseCustomerID resets all changes to the "omise_customer_id" field.
func (m *TutorMutation) ResetOmiseCustomerID() {
	m.omise_customer_id = nil
	delete(m.clearedFields, tutor.FieldOmiseCustomerID)
}

// AddIssueReportIDs adds the "issue_report" edge to the IssueReport entity by ids.
func (m *TutorMutation) AddIssueReportIDs(ids ...uuid.UUID) {
	if m.issue_report == nil {
		m.issue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.issue_report[ids[i]] = struct{}{}
	}
}

// ClearIssueReport clears the "issue_report" edge to the IssueReport entity.
func (m *TutorMutation) ClearIssueReport() {
	m.clearedissue_report = true
}

// IssueReportCleared reports if the "issue_report" edge to the IssueReport entity was cleared.
func (m *TutorMutation) IssueReportCleared() bool {
	return m.clearedissue_report
}

// RemoveIssueReportIDs removes the "issue_report" edge to the IssueReport entity by IDs.
func (m *TutorMutation) RemoveIssueReportIDs(ids ...uuid.UUID) {
	if m.removedissue_report == nil {
		m.removedissue_report = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.issue_report, ids[i])
		m.removedissue_report[ids[i]] = struct{}{}
	}
}

// RemovedIssueReport returns the removed IDs of the "issue_report" edge to the IssueReport entity.
func (m *TutorMutation) RemovedIssueReportIDs() (ids []uuid.UUID) {
	for id := range m.removedissue_report {
		ids = append(ids, id)
	}
	return
}

// IssueReportIDs returns the "issue_report" edge IDs in the mutation.
func (m *TutorMutation) IssueReportIDs() (ids []uuid.UUID) {
	for id := range m.issue_report {
		ids = append(ids, id)
	}
	return
}

// ResetIssueReport resets all changes to the "issue_report" edge.
func (m *TutorMutation) ResetIssueReport() {
	m.issue_report = nil
	m.clearedissue_report = false
	m.removedissue_report = nil
}

// AddCourseIDs adds the "course" edge to the Course entity by ids.
func (m *TutorMutation) AddCourseIDs(ids ...uuid.UUID) {
	if m.course == nil {
		m.course = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *TutorMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *TutorMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the Course entity by IDs.
func (m *TutorMutation) RemoveCourseIDs(ids ...uuid.UUID) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.course, ids[i])
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the Course entity.
func (m *TutorMutation) RemovedCourseIDs() (ids []uuid.UUID) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *TutorMutation) CourseIDs() (ids []uuid.UUID) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *TutorMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TutorMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TutorMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TutorMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TutorMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TutorMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TutorMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetScheduleID sets the "schedule" edge to the Schedule entity by id.
func (m *TutorMutation) SetScheduleID(id uuid.UUID) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the Schedule entity.
func (m *TutorMutation) ClearSchedule() {
	m.clearedschedule = true
}

// ScheduleCleared reports if the "schedule" edge to the Schedule entity was cleared.
func (m *TutorMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *TutorMutation) ScheduleID() (id uuid.UUID, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *TutorMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *TutorMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// Where appends a list predicates to the TutorMutation builder.
func (m *TutorMutation) Where(ps ...predicate.Tutor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TutorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TutorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tutor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TutorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TutorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tutor).
func (m *TutorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TutorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.description != nil {
		fields = append(fields, tutor.FieldDescription)
	}
	if m.omise_bank_token != nil {
		fields = append(fields, tutor.FieldOmiseBankToken)
	}
	if m.citizen_id != nil {
		fields = append(fields, tutor.FieldCitizenID)
	}
	if m.omise_customer_id != nil {
		fields = append(fields, tutor.FieldOmiseCustomerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TutorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tutor.FieldDescription:
		return m.Description()
	case tutor.FieldOmiseBankToken:
		return m.OmiseBankToken()
	case tutor.FieldCitizenID:
		return m.CitizenID()
	case tutor.FieldOmiseCustomerID:
		return m.OmiseCustomerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TutorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tutor.FieldDescription:
		return m.OldDescription(ctx)
	case tutor.FieldOmiseBankToken:
		return m.OldOmiseBankToken(ctx)
	case tutor.FieldCitizenID:
		return m.OldCitizenID(ctx)
	case tutor.FieldOmiseCustomerID:
		return m.OldOmiseCustomerID(ctx)
	}
	return nil, fmt.Errorf("unknown Tutor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TutorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tutor.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tutor.FieldOmiseBankToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOmiseBankToken(v)
		return nil
	case tutor.FieldCitizenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitizenID(v)
		return nil
	case tutor.FieldOmiseCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOmiseCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown Tutor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TutorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TutorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TutorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tutor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TutorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tutor.FieldDescription) {
		fields = append(fields, tutor.FieldDescription)
	}
	if m.FieldCleared(tutor.FieldOmiseBankToken) {
		fields = append(fields, tutor.FieldOmiseBankToken)
	}
	if m.FieldCleared(tutor.FieldOmiseCustomerID) {
		fields = append(fields, tutor.FieldOmiseCustomerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TutorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TutorMutation) ClearField(name string) error {
	switch name {
	case tutor.FieldDescription:
		m.ClearDescription()
		return nil
	case tutor.FieldOmiseBankToken:
		m.ClearOmiseBankToken()
		return nil
	case tutor.FieldOmiseCustomerID:
		m.ClearOmiseCustomerID()
		return nil
	}
	return fmt.Errorf("unknown Tutor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TutorMutation) ResetField(name string) error {
	switch name {
	case tutor.FieldDescription:
		m.ResetDescription()
		return nil
	case tutor.FieldOmiseBankToken:
		m.ResetOmiseBankToken()
		return nil
	case tutor.FieldCitizenID:
		m.ResetCitizenID()
		return nil
	case tutor.FieldOmiseCustomerID:
		m.ResetOmiseCustomerID()
		return nil
	}
	return fmt.Errorf("unknown Tutor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TutorMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.issue_report != nil {
		edges = append(edges, tutor.EdgeIssueReport)
	}
	if m.course != nil {
		edges = append(edges, tutor.EdgeCourse)
	}
	if m.user != nil {
		edges = append(edges, tutor.EdgeUser)
	}
	if m.schedule != nil {
		edges = append(edges, tutor.EdgeSchedule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TutorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tutor.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.issue_report))
		for id := range m.issue_report {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case tutor.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TutorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedissue_report != nil {
		edges = append(edges, tutor.EdgeIssueReport)
	}
	if m.removedcourse != nil {
		edges = append(edges, tutor.EdgeCourse)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TutorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tutor.EdgeIssueReport:
		ids := make([]ent.Value, 0, len(m.removedissue_report))
		for id := range m.removedissue_report {
			ids = append(ids, id)
		}
		return ids
	case tutor.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TutorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedissue_report {
		edges = append(edges, tutor.EdgeIssueReport)
	}
	if m.clearedcourse {
		edges = append(edges, tutor.EdgeCourse)
	}
	if m.cleareduser {
		edges = append(edges, tutor.EdgeUser)
	}
	if m.clearedschedule {
		edges = append(edges, tutor.EdgeSchedule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TutorMutation) EdgeCleared(name string) bool {
	switch name {
	case tutor.EdgeIssueReport:
		return m.clearedissue_report
	case tutor.EdgeCourse:
		return m.clearedcourse
	case tutor.EdgeUser:
		return m.cleareduser
	case tutor.EdgeSchedule:
		return m.clearedschedule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TutorMutation) ClearEdge(name string) error {
	switch name {
	case tutor.EdgeUser:
		m.ClearUser()
		return nil
	case tutor.EdgeSchedule:
		m.ClearSchedule()
		return nil
	}
	return fmt.Errorf("unknown Tutor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TutorMutation) ResetEdge(name string) error {
	switch name {
	case tutor.EdgeIssueReport:
		m.ResetIssueReport()
		return nil
	case tutor.EdgeCourse:
		m.ResetCourse()
		return nil
	case tutor.EdgeUser:
		m.ResetUser()
		return nil
	case tutor.EdgeSchedule:
		m.ResetSchedule()
		return nil
	}
	return fmt.Errorf("unknown Tutor edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	username               *string
	password               *string
	email                  *string
	first_name             *string
	last_name              *string
	address                *string
	phone                  *string
	birth_date             *time.Time
	gender                 *string
	profile_picture_URL    *string
	role                   *user.Role
	clearedFields          map[string]struct{}
	student                *uuid.UUID
	clearedstudent         bool
	tutor                  *uuid.UUID
	clearedtutor           bool
	payment                map[uuid.UUID]struct{}
	removedpayment         map[uuid.UUID]struct{}
	clearedpayment         bool
	payment_history        map[uuid.UUID]struct{}
	removedpayment_history map[uuid.UUID]struct{}
	clearedpayment_history bool
	cancel_request         map[uuid.UUID]struct{}
	removedcancel_request  map[uuid.UUID]struct{}
	clearedcancel_request  bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetBirthDate sets the "birth_date" field.
func (m *UserMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *UserMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *UserMutation) ResetBirthDate() {
	m.birth_date = nil
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
}

// SetProfilePictureURL sets the "profile_picture_URL" field.
func (m *UserMutation) SetProfilePictureURL(s string) {
	m.profile_picture_URL = &s
}

// ProfilePictureURL returns the value of the "profile_picture_URL" field in the mutation.
func (m *UserMutation) ProfilePictureURL() (r string, exists bool) {
	v := m.profile_picture_URL
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureURL returns the old "profile_picture_URL" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfilePictureURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureURL: %w", err)
	}
	return oldValue.ProfilePictureURL, nil
}

// ClearProfilePictureURL clears the value of the "profile_picture_URL" field.
func (m *UserMutation) ClearProfilePictureURL() {
	m.profile_picture_URL = nil
	m.clearedFields[user.FieldProfilePictureURL] = struct{}{}
}

// ProfilePictureURLCleared returns if the "profile_picture_URL" field was cleared in this mutation.
func (m *UserMutation) ProfilePictureURLCleared() bool {
	_, ok := m.clearedFields[user.FieldProfilePictureURL]
	return ok
}

// ResetProfilePictureURL resets all changes to the "profile_picture_URL" field.
func (m *UserMutation) ResetProfilePictureURL() {
	m.profile_picture_URL = nil
	delete(m.clearedFields, user.FieldProfilePictureURL)
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v *user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *UserMutation) SetStudentID(id uuid.UUID) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *UserMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *UserMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *UserMutation) StudentID() (id uuid.UUID, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) StudentIDs() (ids []uuid.UUID) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *UserMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetTutorID sets the "tutor" edge to the Tutor entity by id.
func (m *UserMutation) SetTutorID(id uuid.UUID) {
	m.tutor = &id
}

// ClearTutor clears the "tutor" edge to the Tutor entity.
func (m *UserMutation) ClearTutor() {
	m.clearedtutor = true
}

// TutorCleared reports if the "tutor" edge to the Tutor entity was cleared.
func (m *UserMutation) TutorCleared() bool {
	return m.clearedtutor
}

// TutorID returns the "tutor" edge ID in the mutation.
func (m *UserMutation) TutorID() (id uuid.UUID, exists bool) {
	if m.tutor != nil {
		return *m.tutor, true
	}
	return
}

// TutorIDs returns the "tutor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TutorID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TutorIDs() (ids []uuid.UUID) {
	if id := m.tutor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTutor resets all changes to the "tutor" edge.
func (m *UserMutation) ResetTutor() {
	m.tutor = nil
	m.clearedtutor = false
}

// AddPaymentIDs adds the "payment" edge to the Payment entity by ids.
func (m *UserMutation) AddPaymentIDs(ids ...uuid.UUID) {
	if m.payment == nil {
		m.payment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.payment[ids[i]] = struct{}{}
	}
}

// ClearPayment clears the "payment" edge to the Payment entity.
func (m *UserMutation) ClearPayment() {
	m.clearedpayment = true
}

// PaymentCleared reports if the "payment" edge to the Payment entity was cleared.
func (m *UserMutation) PaymentCleared() bool {
	return m.clearedpayment
}

// RemovePaymentIDs removes the "payment" edge to the Payment entity by IDs.
func (m *UserMutation) RemovePaymentIDs(ids ...uuid.UUID) {
	if m.removedpayment == nil {
		m.removedpayment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.payment, ids[i])
		m.removedpayment[ids[i]] = struct{}{}
	}
}

// RemovedPayment returns the removed IDs of the "payment" edge to the Payment entity.
func (m *UserMutation) RemovedPaymentIDs() (ids []uuid.UUID) {
	for id := range m.removedpayment {
		ids = append(ids, id)
	}
	return
}

// PaymentIDs returns the "payment" edge IDs in the mutation.
func (m *UserMutation) PaymentIDs() (ids []uuid.UUID) {
	for id := range m.payment {
		ids = append(ids, id)
	}
	return
}

// ResetPayment resets all changes to the "payment" edge.
func (m *UserMutation) ResetPayment() {
	m.payment = nil
	m.clearedpayment = false
	m.removedpayment = nil
}

// AddPaymentHistoryIDs adds the "payment_history" edge to the PaymentHistory entity by ids.
func (m *UserMutation) AddPaymentHistoryIDs(ids ...uuid.UUID) {
	if m.payment_history == nil {
		m.payment_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.payment_history[ids[i]] = struct{}{}
	}
}

// ClearPaymentHistory clears the "payment_history" edge to the PaymentHistory entity.
func (m *UserMutation) ClearPaymentHistory() {
	m.clearedpayment_history = true
}

// PaymentHistoryCleared reports if the "payment_history" edge to the PaymentHistory entity was cleared.
func (m *UserMutation) PaymentHistoryCleared() bool {
	return m.clearedpayment_history
}

// RemovePaymentHistoryIDs removes the "payment_history" edge to the PaymentHistory entity by IDs.
func (m *UserMutation) RemovePaymentHistoryIDs(ids ...uuid.UUID) {
	if m.removedpayment_history == nil {
		m.removedpayment_history = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.payment_history, ids[i])
		m.removedpayment_history[ids[i]] = struct{}{}
	}
}

// RemovedPaymentHistory returns the removed IDs of the "payment_history" edge to the PaymentHistory entity.
func (m *UserMutation) RemovedPaymentHistoryIDs() (ids []uuid.UUID) {
	for id := range m.removedpayment_history {
		ids = append(ids, id)
	}
	return
}

// PaymentHistoryIDs returns the "payment_history" edge IDs in the mutation.
func (m *UserMutation) PaymentHistoryIDs() (ids []uuid.UUID) {
	for id := range m.payment_history {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentHistory resets all changes to the "payment_history" edge.
func (m *UserMutation) ResetPaymentHistory() {
	m.payment_history = nil
	m.clearedpayment_history = false
	m.removedpayment_history = nil
}

// AddCancelRequestIDs adds the "cancel_request" edge to the CancelRequest entity by ids.
func (m *UserMutation) AddCancelRequestIDs(ids ...uuid.UUID) {
	if m.cancel_request == nil {
		m.cancel_request = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cancel_request[ids[i]] = struct{}{}
	}
}

// ClearCancelRequest clears the "cancel_request" edge to the CancelRequest entity.
func (m *UserMutation) ClearCancelRequest() {
	m.clearedcancel_request = true
}

// CancelRequestCleared reports if the "cancel_request" edge to the CancelRequest entity was cleared.
func (m *UserMutation) CancelRequestCleared() bool {
	return m.clearedcancel_request
}

// RemoveCancelRequestIDs removes the "cancel_request" edge to the CancelRequest entity by IDs.
func (m *UserMutation) RemoveCancelRequestIDs(ids ...uuid.UUID) {
	if m.removedcancel_request == nil {
		m.removedcancel_request = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cancel_request, ids[i])
		m.removedcancel_request[ids[i]] = struct{}{}
	}
}

// RemovedCancelRequest returns the removed IDs of the "cancel_request" edge to the CancelRequest entity.
func (m *UserMutation) RemovedCancelRequestIDs() (ids []uuid.UUID) {
	for id := range m.removedcancel_request {
		ids = append(ids, id)
	}
	return
}

// CancelRequestIDs returns the "cancel_request" edge IDs in the mutation.
func (m *UserMutation) CancelRequestIDs() (ids []uuid.UUID) {
	for id := range m.cancel_request {
		ids = append(ids, id)
	}
	return
}

// ResetCancelRequest resets all changes to the "cancel_request" edge.
func (m *UserMutation) ResetCancelRequest() {
	m.cancel_request = nil
	m.clearedcancel_request = false
	m.removedcancel_request = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.birth_date != nil {
		fields = append(fields, user.FieldBirthDate)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.profile_picture_URL != nil {
		fields = append(fields, user.FieldProfilePictureURL)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAddress:
		return m.Address()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldBirthDate:
		return m.BirthDate()
	case user.FieldGender:
		return m.Gender()
	case user.FieldProfilePictureURL:
		return m.ProfilePictureURL()
	case user.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldProfilePictureURL:
		return m.OldProfilePictureURL(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case user.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldProfilePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureURL(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldProfilePictureURL) {
		fields = append(fields, user.FieldProfilePictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldProfilePictureURL:
		m.ClearProfilePictureURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldProfilePictureURL:
		m.ResetProfilePictureURL()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.student != nil {
		edges = append(edges, user.EdgeStudent)
	}
	if m.tutor != nil {
		edges = append(edges, user.EdgeTutor)
	}
	if m.payment != nil {
		edges = append(edges, user.EdgePayment)
	}
	if m.payment_history != nil {
		edges = append(edges, user.EdgePaymentHistory)
	}
	if m.cancel_request != nil {
		edges = append(edges, user.EdgeCancelRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTutor:
		if id := m.tutor; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePayment:
		ids := make([]ent.Value, 0, len(m.payment))
		for id := range m.payment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePaymentHistory:
		ids := make([]ent.Value, 0, len(m.payment_history))
		for id := range m.payment_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCancelRequest:
		ids := make([]ent.Value, 0, len(m.cancel_request))
		for id := range m.cancel_request {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedpayment != nil {
		edges = append(edges, user.EdgePayment)
	}
	if m.removedpayment_history != nil {
		edges = append(edges, user.EdgePaymentHistory)
	}
	if m.removedcancel_request != nil {
		edges = append(edges, user.EdgeCancelRequest)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePayment:
		ids := make([]ent.Value, 0, len(m.removedpayment))
		for id := range m.removedpayment {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePaymentHistory:
		ids := make([]ent.Value, 0, len(m.removedpayment_history))
		for id := range m.removedpayment_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCancelRequest:
		ids := make([]ent.Value, 0, len(m.removedcancel_request))
		for id := range m.removedcancel_request {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedstudent {
		edges = append(edges, user.EdgeStudent)
	}
	if m.clearedtutor {
		edges = append(edges, user.EdgeTutor)
	}
	if m.clearedpayment {
		edges = append(edges, user.EdgePayment)
	}
	if m.clearedpayment_history {
		edges = append(edges, user.EdgePaymentHistory)
	}
	if m.clearedcancel_request {
		edges = append(edges, user.EdgeCancelRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeStudent:
		return m.clearedstudent
	case user.EdgeTutor:
		return m.clearedtutor
	case user.EdgePayment:
		return m.clearedpayment
	case user.EdgePaymentHistory:
		return m.clearedpayment_history
	case user.EdgeCancelRequest:
		return m.clearedcancel_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeStudent:
		m.ClearStudent()
		return nil
	case user.EdgeTutor:
		m.ClearTutor()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeStudent:
		m.ResetStudent()
		return nil
	case user.EdgeTutor:
		m.ResetTutor()
		return nil
	case user.EdgePayment:
		m.ResetPayment()
		return nil
	case user.EdgePaymentHistory:
		m.ResetPaymentHistory()
		return nil
	case user.EdgeCancelRequest:
		m.ResetCancelRequest()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
